---
description: Database Design for Meeting Room System
globs:
alwaysApply: true
---

# 회의실 관리 시스템 데이터베이스 설계

## 개요
Next.js 14+ (App Router) + Supabase(PostgreSQL) + Vercel 스택을 사용한 회의실 관리 시스템의 데이터베이스 설계 문서입니다. TypeScript와 함께 최소 스펙의 MVP 구현을 위한 데이터플로우와 스키마를 정의합니다.

## 데이터플로우

### 1. 회의실 데이터 흐름

#### 1.1 회의실 등록 (관리자)
```
관리자 입력 → TypeScript 타입 검증 → Zod 유효성 검증 → 중복 확인 → meeting_rooms 테이블 INSERT
```

#### 1.2 회의실 조회 (전체)
```
사용자/관리자 요청 → Supabase Client → meeting_rooms 테이블 SELECT → TypeScript 타입 반환
```

#### 1.3 회의실 수정 (관리자)
```
관리자 입력 → 권한 확인 → 기존 예약 확인 → meeting_rooms 테이블 UPDATE → Realtime 업데이트
```

#### 1.4 회의실 삭제 (관리자)
```
관리자 요청 → 권한 확인 → reservations 테이블 확인 → 경고/확인 → meeting_rooms 테이블 CASCADE DELETE
```

### 2. 예약 데이터 흐름

#### 2.1 예약 현황 조회
```
사용자 요청 → meeting_rooms + reservations 테이블 JOIN → RoomWithReservations 타입 반환
```

#### 2.2 예약 생성
```
사용자 입력 → Zod 스키마 검증 → 시간 중복 확인 → reservations 테이블 INSERT → Realtime 현황 업데이트
```

#### 2.3 내 예약 조회
```
휴대폰번호+비밀번호 입력 → 형식 검증 → reservations 테이블 WHERE 조건 필터링 → Reservation[] 반환
```

#### 2.4 예약 취소
```
예약 ID + 인증 → 취소 가능 시간 확인 → reservations 테이블 status UPDATE → Realtime 동기화
```

### 3. 실시간 동기화 흐름
```
데이터 변경 이벤트 → Supabase Realtime → TypeScript 타입 체크 → 클라이언트 실시간 업데이트
```

## 데이터베이스 스키마

### 테이블 구조

#### 1. meeting_rooms (회의실 정보)
```sql
CREATE TABLE IF NOT EXISTS meeting_rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    location VARCHAR(200) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**TypeScript 인터페이스:**
```typescript
interface MeetingRoom {
  id: string;
  name: string;
  location: string;
  capacity: number;
  created_at: string;
  updated_at: string;
}
```

**필드 설명:**
- `id`: 회의실 고유 식별자 (UUID)
- `name`: 회의실 이름 (중복 불가, UNIQUE 제약)
- `location`: 회의실 위치
- `capacity`: 수용 가능 인원수 (양수, CHECK 제약)
- `created_at`: 생성 일시 (자동 생성)
- `updated_at`: 수정 일시 (트리거로 자동 업데이트)

#### 2. reservations (예약 정보)
```sql
CREATE TABLE IF NOT EXISTS reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE,
    reservation_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    reserver_phone VARCHAR(20) NOT NULL,
    reserver_password VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**TypeScript 인터페이스:**
```typescript
interface Reservation {
  id: string;
  room_id: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
  status: 'active' | 'cancelled';
  created_at: string;
  updated_at: string;
}
```

**필드 설명:**
- `id`: 예약 고유 식별자 (UUID)
- `room_id`: 회의실 참조 (외래키, CASCADE 삭제)
- `reservation_date`: 예약 날짜 (DATE 타입)
- `start_time`: 시작 시간 (TIME 타입)
- `end_time`: 종료 시간 (TIME 타입)
- `reserver_name`: 예약자 이름
- `reserver_phone`: 예약자 휴대폰번호 (조회 키)
- `reserver_password`: 예약 비밀번호 (조회 인증)
- `status`: 예약 상태 (active, cancelled)
- `created_at`: 예약 생성 일시
- `updated_at`: 예약 수정 일시

### 제약 조건

#### 1. 시간 중복 방지 (GIST 제약조건)
```sql
-- GIST 확장 활성화
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- 동일 회의실, 동일 날짜의 시간 중복 방지
ALTER TABLE reservations
ADD CONSTRAINT no_overlapping_reservations
EXCLUDE USING GIST (
    room_id WITH =,
    reservation_date WITH =,
    tsrange(start_time::text, end_time::text) WITH &&
) WHERE (status = 'active');
```

**설명:**
- PostgreSQL의 GIST 인덱스를 활용한 시간 범위 겹침 방지
- 동일 회의실, 동일 날짜에서 활성 예약 시간 겹침 방지
- 취소된 예약(`status = 'cancelled'`)은 제약에서 제외
- 동시성 제어를 데이터베이스 레벨에서 보장

#### 2. 참조 무결성
```sql
room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE
```
**설명:** 
- 회의실 삭제 시 관련 예약도 함께 삭제 (CASCADE DELETE)
- 데이터 일관성 보장

#### 3. 데이터 유효성 제약
```sql
-- 수용 인원 양수 제약
capacity INTEGER NOT NULL CHECK (capacity > 0)

-- 예약 상태 제약
status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled'))
```

### 성능 최적화 인덱스

#### 1. 예약 조회 최적화
```sql
-- 휴대폰번호 기반 예약 조회 (내 예약 조회)
CREATE INDEX IF NOT EXISTS idx_reservations_phone ON reservations(reserver_phone);

-- 날짜별 예약 현황 조회 (전체 현황 조회)
CREATE INDEX IF NOT EXISTS idx_reservations_date_room ON reservations(reservation_date, room_id, status);
```

#### 2. 회의실 조회 최적화
```sql
-- 회의실명 검색
CREATE INDEX IF NOT EXISTS idx_meeting_rooms_name ON meeting_rooms(name);
```

### 주요 쿼리 패턴

#### 1. 전체 예약 현황 조회 (TypeScript)
```typescript
// Supabase 클라이언트 쿼리
async function getReservationsByDate(date: string): Promise<RoomWithReservations[]> {
  const { data, error } = await supabase
    .from('meeting_rooms')
    .select(`
      *,
      reservations!inner(
        id,
        reservation_date,
        start_time,
        end_time,
        reserver_name,
        status
      )
    `)
    .eq('reservations.reservation_date', date)
    .eq('reservations.status', 'active')
    .order('name');
  
  if (error) throw error;
  return data as RoomWithReservations[];
}
```

**해당 SQL:**
```sql
SELECT 
    mr.id, 
    mr.name, 
    mr.location, 
    mr.capacity,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', r.id,
                'start_time', r.start_time,
                'end_time', r.end_time,
                'reserver_name', r.reserver_name,
                'status', r.status
            ) ORDER BY r.start_time
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'::json
    ) as reservations
FROM meeting_rooms mr
LEFT JOIN reservations r ON mr.id = r.room_id 
    AND r.reservation_date = $1
    AND r.status = 'active'
GROUP BY mr.id, mr.name, mr.location, mr.capacity
ORDER BY mr.name;
```

#### 2. 내 예약 조회 (TypeScript)
```typescript
async function getMyReservations(phone: string, password: string): Promise<Reservation[]> {
  const { data, error } = await supabase
    .from('reservations')
    .select(`
      *,
      meeting_rooms(name, location)
    `)
    .eq('reserver_phone', phone)
    .eq('reserver_password', password)
    .order('reservation_date', { ascending: false });
  
  if (error) throw error;
  return data;
}
```

**해당 SQL:**
```sql
SELECT 
    r.id, 
    mr.name, 
    mr.location, 
    r.reservation_date, 
    r.start_time, 
    r.end_time, 
    r.status
FROM reservations r
JOIN meeting_rooms mr ON r.room_id = mr.id
WHERE r.reserver_phone = $1 AND r.reserver_password = $2
ORDER BY r.reservation_date DESC, r.start_time DESC;
```

#### 3. 예약 시간 중복 확인 (PostgreSQL 함수)
```sql
-- 시간 중복 확인 함수
CREATE OR REPLACE FUNCTION check_time_conflict(
    p_room_id UUID,
    p_date DATE,
    p_start_time TIME,
    p_end_time TIME
)
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)::INTEGER
        FROM reservations 
        WHERE room_id = p_room_id 
        AND reservation_date = p_date 
        AND status = 'active'
        AND tsrange(p_start_time::text, p_end_time::text) && tsrange(start_time::text, end_time::text)
    );
END;
$$ LANGUAGE plpgsql;
```

**TypeScript 호출:**
```typescript
async function checkTimeConflict(
  roomId: string, 
  date: string, 
  startTime: string, 
  endTime: string
): Promise<boolean> {
  const { data, error } = await supabase
    .rpc('check_time_conflict', {
      p_room_id: roomId,
      p_date: date,
      p_start_time: startTime,
      p_end_time: endTime
    });
  
  if (error) throw error;
  return data > 0;
}
```

## 데이터 무결성 보장

### 1. 동시성 제어
- **PostgreSQL의 GIST 인덱스**: 시간 범위 겹침 방지
- **트랜잭션 레벨**: 예약 중복 방지
- **TypeScript 타입 체크**: 컴파일 타임 오류 방지

### 2. 데이터 일관성
- **외래키 제약**: 참조 무결성 보장 (CASCADE DELETE)
- **CHECK 제약**: 유효한 데이터 값 보장 (양수, 상태값)
- **Zod 스키마**: 런타임 데이터 검증

### 3. 실시간 동기화
```typescript
// Supabase Realtime 구독
const subscription = supabase
  .channel('reservations')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'reservations'
  }, (payload: RealtimePostgresChangesPayload<Reservation>) => {
    // TypeScript 타입 안전성 보장
    switch(payload.eventType) {
      case 'INSERT':
        setReservations(prev => [...prev, payload.new]);
        break;
      case 'UPDATE':
        setReservations(prev => 
          prev.map(r => r.id === payload.new.id ? payload.new : r)
        );
        break;
      case 'DELETE':
        setReservations(prev => 
          prev.filter(r => r.id !== payload.old.id)
        );
        break;
    }
  })
  .subscribe();
```

## 자동화 트리거

### updated_at 자동 업데이트
```sql
-- updated_at 자동 업데이트 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- meeting_rooms 테이블에 트리거 적용
CREATE TRIGGER update_meeting_rooms_updated_at
    BEFORE UPDATE ON meeting_rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- reservations 테이블에 트리거 적용
CREATE TRIGGER update_reservations_updated_at
    BEFORE UPDATE ON reservations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## TypeScript 데이터베이스 타입

### Supabase 생성 타입 정의
```typescript
// types/database.ts
export interface Database {
  public: {
    Tables: {
      meeting_rooms: {
        Row: MeetingRoom;
        Insert: Omit<MeetingRoom, 'id' | 'created_at' | 'updated_at'> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: Partial<Omit<MeetingRoom, 'id' | 'created_at' | 'updated_at'>>;
      };
      reservations: {
        Row: Reservation;
        Insert: Omit<Reservation, 'id' | 'created_at' | 'updated_at'> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: Partial<Omit<Reservation, 'id' | 'created_at' | 'updated_at'>>;
      };
    };
  };
}

// 확장 타입 정의
export interface RoomWithReservations extends MeetingRoom {
  reservations: Reservation[];
}

export interface CreateRoomData {
  name: string;
  location: string;
  capacity: number;
}

export interface CreateReservationData {
  room_id: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
}
```

## 더미 데이터 구조

### 회의실 더미 데이터 (5개)
```sql
INSERT INTO meeting_rooms (name, location, capacity) VALUES
('휴게실 A', '1층 동쪽', 4),
('휴게실 B', '1층 서쪽', 6),
('휴게실 C', '2층 중앙', 8),
('휴게실 D', '2층 북쪽', 4),
('휴게실 E', '3층 남쪽', 10)
ON CONFLICT (name) DO NOTHING;
```

### 예약 더미 데이터 패턴
```sql
-- 현재 날짜부터 일주일간의 예약 데이터
-- 다양한 시간대와 휴대폰번호/비밀번호 조합
-- 일부 취소된 예약 포함 (status = 'cancelled')
INSERT INTO reservations (room_id, reservation_date, start_time, end_time, reserver_name, reserver_phone, reserver_password, status)
SELECT
    (SELECT id FROM meeting_rooms WHERE name = '휴게실 A'),
    CURRENT_DATE,
    '09:00',
    '10:00',
    '김철수',
    '010-1234-5678',
    'password123',
    'active'
UNION ALL
-- ... 추가 더미 데이터
SELECT
    (SELECT id FROM meeting_rooms WHERE name = '휴게실 B'),
    CURRENT_DATE - 1,
    '13:00',
    '14:00',
    '이취소',
    '010-9999-9999',
    'cancelled123',
    'cancelled';
```

## 확장성 고려사항

### 1. 파티셔닝 (필요시)
```sql
-- 예약 테이블을 날짜별로 파티셔닝 (대용량 데이터 시)
CREATE TABLE reservations_2024 PARTITION OF reservations
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

### 2. 아카이브 전략 (필요시)
```sql
-- 과거 예약 데이터의 별도 테이블 보관
CREATE TABLE reservations_archive AS 
SELECT * FROM reservations 
WHERE reservation_date < CURRENT_DATE - INTERVAL '1 year';
```

### 3. 캐싱 전략 (TypeScript)
```typescript
// React Query를 활용한 캐싱 (선택적)
const { data: rooms } = useQuery({
  queryKey: ['rooms'],
  queryFn: () => roomService.getAllRooms(),
  staleTime: 5 * 60 * 1000, // 5분간 캐시
});

// 메모리 캐싱 (간단한 방법)
const roomsCache = new Map<string, MeetingRoom>();
```

## RLS 정책 (비활성화)

요구사항에 따라 Row Level Security는 비활성화하여 단순한 구조로 유지합니다.

```sql
ALTER TABLE meeting_rooms DISABLE ROW LEVEL SECURITY;
ALTER TABLE reservations DISABLE ROW LEVEL SECURITY;
```

## Migration 파일 구조

### 단일 Migration 파일
```sql
-- /supabase/migrations/20241215000001_init_meeting_room_system.sql
-- 1. 확장 활성화 (btree_gist)
-- 2. 테이블 생성 (meeting_rooms, reservations)
-- 3. 제약조건 추가 (GIST, 외래키, CHECK)
-- 4. 인덱스 생성 (성능 최적화)
-- 5. RLS 비활성화
-- 6. 트리거 함수 생성 (updated_at 자동화)
-- 7. PostgreSQL 함수 생성 (중복 확인)
-- 8. 더미 데이터 삽입 (개발/테스트용)
```

## 데이터베이스 검증 및 테스트

### TypeScript 타입 체크
```typescript
// 컴파일 타임 타입 검증
const reservation: CreateReservationData = {
  room_id: "uuid-string",
  reservation_date: "2024-12-15",
  start_time: "14:00",
  end_time: "15:30",
  reserver_name: "홍길동",
  reserver_phone: "010-1234-5678",
  reserver_password: "secure123"
};

// Zod 런타임 검증
const validatedData = reservationSchema.parse(reservation);
```

### 데이터베이스 제약조건 테스트
```sql
-- 시간 중복 테스트 (실패해야 함)
INSERT INTO reservations (room_id, reservation_date, start_time, end_time, reserver_name, reserver_phone, reserver_password)
VALUES 
    ('same-room-id', '2024-12-15', '14:00', '15:00', '사용자1', '010-1111-1111', 'pass1'),
    ('same-room-id', '2024-12-15', '14:30', '15:30', '사용자2', '010-2222-2222', 'pass2');
-- 에러: exclusion constraint "no_overlapping_reservations" violated
```

이 데이터베이스 설계는 TypeScript와 Next.js App Router를 기반으로 한 안정적이고 확장 가능한 회의실 관리 시스템 구현을 위한 완전한 데이터 계층을 제공합니다.