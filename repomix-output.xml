This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/rules/clean-code.mdc
.cursor/rules/gistfile1.mdc
.cursor/rules/git-commit-message.mdc
.cursor/rules/global.mdc
.cursor/rules/stepbystep.mdc
.cursor/rules/supabase.mdc
.cursor/rules/TDD.mdc
.cursor/user.mdc
.cursorignore
.gitignore
components.json
doc/datebase.mdc
doc/prd.mdc
doc/trd.mdc
doc/userflow.mdc
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
src/app/admin/login/page.test.tsx
src/app/admin/login/page.tsx
src/app/admin/page.test.tsx
src/app/admin/page.tsx
src/app/api/admin/auth/route.ts
src/app/api/admin/rooms/route.ts
src/app/globals.css
src/app/layout.tsx
src/app/my-reservations/page.test.tsx
src/app/my-reservations/page.tsx
src/app/page.tsx
src/app/providers.tsx
src/components/ui/accordion.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/file-upload.tsx
src/components/ui/form.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/textarea.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/hooks/use-toast.ts
src/lib/auth/admin.ts
src/lib/services/reservations.ts
src/lib/services/rooms.ts
src/lib/supabase/client.ts
src/lib/supabase/server.ts
src/lib/supabase/service.ts
src/lib/utils.ts
src/middleware.ts
src/test/setup.ts
src/types/database.ts
src/types/index.ts
supabase/.gitignore
supabase/config.toml
supabase/migrations/20250915000000_initial_schema.sql
supabase/migrations/20250915130455_create_users_table.sql
supabase/migrations/20250915223000_add_reservations_end_after_start_check.sql
supabase/migrations/20250915224000_enable_rls_and_index.sql
supabase/migrations/20250915230000_security_hardening.sql
supabase/migrations/20250915231000_get_my_reservations_rpc.sql
supabase/migrations/20250915232000_enable_pgcrypto_and_hash_passwords.sql
supabase/migrations/20250916110000_disable_rls_for_dev.sql
tailwind.config.ts
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/user.mdc">
---
description:
globs:
alwaysApply: true
---
</file>

<file path="src/app/admin/login/page.test.tsx">
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import AdminLoginPage from './page';
import { vi } from 'vitest';

// Mock global fetch
global.fetch = vi.fn();

// Mock window.location
const originalLocation = window.location;
Object.defineProperty(window, 'location', {
  configurable: true,
  value: { ...originalLocation, href: '' },
});

describe('AdminLoginPage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    window.location.href = '';
  });

  it('should redirect to /admin on successful login', async () => {
    // Arrange
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true });
    render(<AdminLoginPage />);

    // Act
    fireEvent.change(screen.getByLabelText('관리자 토큰'), { target: { value: 'good-token' } });
    fireEvent.click(screen.getByRole('button', { name: '로그인' }));

    // Assert
    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/api/admin/auth', expect.any(Object));
    });
    await waitFor(() => {
      expect(window.location.href).toBe('/admin');
    });
  });

  it('should display an error message on failed login', async () => {
    // Arrange
    (fetch as vi.Mock).mockResolvedValueOnce({
      ok: false,
      json: () => Promise.resolve({ error: 'Invalid token' }),
    });
    render(<AdminLoginPage />);

    // Act
    fireEvent.change(screen.getByLabelText('관리자 토큰'), { target: { value: 'bad-token' } });
    fireEvent.click(screen.getByRole('button', { name: '로그인' }));

    // Assert
    await waitFor(() => {
      expect(screen.getByText('Invalid token')).toBeInTheDocument();
    });
    expect(window.location.href).not.toBe('/admin');
  });
});
</file>

<file path="src/app/admin/page.test.tsx">
import { render, screen, fireEvent, waitFor, within } from '@testing-library/react';
import AdminPage from './page';
import { vi } from 'vitest';

// Mock global fetch and confirm
global.fetch = vi.fn();
window.confirm = vi.fn(() => true); // Assume user always confirms

// Mock the Supabase client
const mockChannel = {
  on: vi.fn().mockReturnThis(),
  subscribe: vi.fn(),
  unsubscribe: vi.fn(),
};
const mockSupabase = {
  channel: vi.fn(() => mockChannel),
  removeChannel: vi.fn(),
};

vi.mock('@/lib/supabase/client', () => ({
  createClient: () => mockSupabase,
}));

describe('AdminPage', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should display unauthorized message if fetch returns 401', async () => {
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: false, status: 401, json: () => Promise.resolve({ error: 'Unauthorized' }) });
    render(<AdminPage />);
    await waitFor(() => {
      expect(screen.getByText('관리자 권한이 필요합니다.')).toBeInTheDocument();
    });
  });

  it('should display a list of rooms on successful fetch', async () => {
    const mockRooms = [{ id: '1', name: 'Room 1', location: '1F', capacity: 10 }];
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: mockRooms }) });
    render(<AdminPage />);
    await waitFor(() => {
      expect(screen.getByText('Room 1')).toBeInTheDocument();
    });
  });

  it('should allow creating a new room', async () => {
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: [] }) });
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: { id: '3', name: 'New Room', location: '3F', capacity: 8 } }) });
    const newMockRooms = [{ id: '3', name: 'New Room', location: '3F', capacity: 8 }];
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: newMockRooms }) });

    render(<AdminPage />);

    fireEvent.change(screen.getByLabelText('이름'), { target: { value: 'New Room' } });
    fireEvent.change(screen.getByLabelText('위치'), { target: { value: '3F' } });
    fireEvent.change(screen.getByLabelText('수용 인원'), { target: { value: '8' } });
    fireEvent.click(screen.getByTestId('submit-button'));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/api/admin/rooms', expect.objectContaining({ method: 'POST' }));
    });
    await waitFor(() => {
      expect(screen.getByText('New Room')).toBeInTheDocument();
    });
  });

  it('should allow editing a room', async () => {
    const initialRooms = [{ id: '1', name: 'Old Name', location: '1F', capacity: 10 }];
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: initialRooms }) });
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: { id: '1', name: 'New Name', location: '1F', capacity: 10 } }) });
    const updatedRooms = [{ id: '1', name: 'New Name', location: '1F', capacity: 10 }];
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: updatedRooms }) });

    render(<AdminPage />);

    const listItem = await screen.findByText('Old Name');
    const parentLi = listItem.closest('li');
    const editButton = within(parentLi!).getByRole('button', { name: '수정' });
    fireEvent.click(editButton);

    await waitFor(() => {
      expect(screen.getByLabelText('이름')).toHaveValue('Old Name');
    });

    fireEvent.change(screen.getByLabelText('이름'), { target: { value: 'New Name' } });
    fireEvent.click(screen.getByTestId('submit-button'));

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/api/admin/rooms', expect.objectContaining({ method: 'PUT' }));
    });
    await waitFor(() => {
      expect(screen.getByText('New Name')).toBeInTheDocument();
    });
  });

  it('should allow deleting a room', async () => {
    const initialRooms = [{ id: '1', name: 'To Delete', location: '1F', capacity: 10 }];
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: initialRooms }) });
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({}) }); // DELETE response
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: [] }) }); // Reload response

    render(<AdminPage />);

    const listItem = await screen.findByText('To Delete');
    const parentLi = listItem.closest('li');
    const deleteButton = within(parentLi!).getByRole('button', { name: '삭제' });
    fireEvent.click(deleteButton);

    expect(window.confirm).toHaveBeenCalled();

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/api/admin/rooms?id=1', { method: 'DELETE' });
    });
    await waitFor(() => {
      expect(screen.queryByText('To Delete')).not.toBeInTheDocument();
    });
  });

  it('should reload rooms on database change event', async () => {
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: [] }) });
    render(<AdminPage />);

    // Wait for initial render and subscription setup
    await waitFor(() => expect(mockSupabase.channel).toHaveBeenCalledWith('meeting_rooms:realtime'));

    // Find the callback function passed to .on()
    const onCallback = mockChannel.on.mock.calls[0][2];
    expect(onCallback).toBeInstanceOf(Function);

    // Simulate a database change event
    (fetch as vi.Mock).mockResolvedValueOnce({ ok: true, json: () => Promise.resolve({ data: [{ id: 'realtime', name: 'Realtime Room' }] }) });
    await onCallback({});

    // Assert that fetch was called again to reload data
    await waitFor(() => {
      expect(fetch).toHaveBeenCalledTimes(2);
      expect(screen.getByText('Realtime Room')).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/app/my-reservations/page.test.tsx">
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import MyReservationsPage from './page';
import * as reservationService from '@/lib/services/reservations';
import { vi } from 'vitest';

// Mock the services
vi.mock('@/lib/services/reservations');
const mockedGetMyReservations = vi.mocked(reservationService.getMyReservations);
const mockedCancelReservation = vi.mocked(reservationService.cancelReservation);

// Mock the useToast hook
const mockToast = vi.fn();
vi.mock('@/hooks/use-toast', () => ({
  useToast: () => ({ toast: mockToast }),
}));

describe('MyReservationsPage', () => {
  beforeEach(() => {
    // Clear mocks before each test
    vi.clearAllMocks();
  });

  it('should display reservations when correct credentials are provided', async () => {
    // Arrange
    const mockReservations = [
      { id: '1', reservation_date: '2025-09-20', start_time: '10:00:00', end_time: '11:00:00', status: 'active' },
      { id: '2', reservation_date: '2025-09-21', start_time: '14:00:00', end_time: '15:00:00', status: 'cancelled' },
    ];
    mockedGetMyReservations.mockResolvedValue({ success: true, data: mockReservations });

    render(<MyReservationsPage />);

    // Act
    fireEvent.change(screen.getByLabelText('전화번호'), { target: { value: '010-1234-5678' } });
    fireEvent.change(screen.getByLabelText('비밀번호'), { target: { value: 'password123' } });
    fireEvent.click(screen.getByRole('button', { name: '조회' }));

    // Assert
    await waitFor(() => {
      expect(screen.getByText('2025-09-20 · 10:00~11:00')).toBeInTheDocument();
    });
    expect(screen.getByText('총 2건')).toBeInTheDocument();
  });

  it('should show a toast message when no reservations are found', async () => {
    // Arrange
    mockedGetMyReservations.mockResolvedValue({ success: true, data: [] });

    render(<MyReservationsPage />);

    // Act
    fireEvent.click(screen.getByRole('button', { name: '조회' }));

    // Assert
    await waitFor(() => {
      expect(mockToast).toHaveBeenCalledWith({ description: '예약 내역이 없습니다.' });
    });
  });

  it('should call cancelReservation when the cancel button is clicked', async () => {
    // Arrange
    const mockReservations = [
      { id: '1', reservation_date: '2025-09-20', start_time: '10:00:00', end_time: '11:00:00', status: 'active' },
    ];
    mockedGetMyReservations.mockResolvedValue({ success: true, data: mockReservations });
    // Mock the cancel function to return success, and get to re-fetch
    mockedCancelReservation.mockResolvedValue({ success: true });

    render(<MyReservationsPage />);

    // Act: First, search for the reservation
    fireEvent.change(screen.getByLabelText('전화번호'), { target: { value: '010-1234-5678' } });
    fireEvent.change(screen.getByLabelText('비밀번호'), { target: { value: 'password123' } });
    fireEvent.click(screen.getByRole('button', { name: '조회' }));

    // Wait for the reservation to appear and then click cancel
    const cancelButton = await screen.findByRole('button', { name: '취소' });
    fireEvent.click(cancelButton);

    // Assert
    await waitFor(() => {
      expect(mockedCancelReservation).toHaveBeenCalledWith('1', '010-1234-5678', 'password123');
    });
    // Check if toast is shown
    await waitFor(() => {
      expect(mockToast).toHaveBeenCalledWith({ description: '예약이 취소되었습니다.' });
    });
  });
});
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="supabase/migrations/20250916110000_disable_rls_for_dev.sql">
-- Disabling Row Level Security for development purposes
ALTER TABLE public.meeting_rooms DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.reservations DISABLE ROW LEVEL SECURITY;
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
</file>

<file path=".cursorignore">
pnpm-lock.yaml
yarn.lock
package-lock.json
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# EasyNext
.easynext

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="doc/userflow.mdc">
---
description: User Flow for Meeting Room System  
globs: 
alwaysApply: true
---

# 회의실 관리 시스템 유저플로우

## 개요
본 문서는 Next.js 14+ (App Router) + Supabase + Vercel 스택을 사용한 회의실 관리 시스템의 핵심 유저플로우를 정의합니다. TypeScript 기반으로 시스템은 관리자(회의실 CRUD)와 사용자(예약 및 조회) 기능으로 구분됩니다.

## 1. 회의실 예약 (사용자)

### 입력 (사용자 상호작용)
1. 전체 예약 현황 페이지 접근 (`app/page.tsx`)
2. 회의실별 예약 현황 확인 (날짜별, 시간대별 예약 상태 조회)
3. 특정 회의실의 "예약하기" 버튼 클릭
4. 예약 모달에서 날짜 선택
5. 사용 가능한 시간대 중 원하는 시간 선택
6. 예약자 정보 입력 (이름, 휴대폰번호, 비밀번호)
7. 예약 확인 버튼 클릭

### 처리 (시스템 내부 로직)
1. **전체 회의실 예약 현황 데이터 조회 및 표시**
   ```typescript
   const rooms: RoomWithReservations[] = await roomService.getReservationsByDate(selectedDate);
   ```

2. **실시간 예약 상태 업데이트** (Supabase Realtime)
   ```typescript
   const subscription = supabase
     .channel('reservations')
     .on('postgres_changes', { event: '*', table: 'reservations' }, handleUpdate)
     .subscribe();
   ```

3. **선택한 회의실의 해당 날짜/시간 예약 가능 여부 재확인**
   ```typescript
   const isConflict = await reservationService.checkTimeConflict(roomId, date, startTime, endTime);
   ```

4. **입력 데이터 유효성 검증** (Zod 스키마 활용)
   ```typescript
   const validatedData = reservationSchema.parse(formData);
   ```

5. **동시성 처리** (GIST 제약조건으로 중복 방지)
6. **예약 데이터 Supabase 저장**
7. **전체 예약 현황 페이지 데이터 갱신**

### 출력 (사용자 피드백)
- **초기 진입**: 모든 회의실의 예약 현황 시각적 표시 (그리드 형태)
- **예약 진행**: 선택한 회의실 정보 및 사용 가능 시간 표시
- **성공 시**: 예약 완료 메시지, 업데이트된 전체 예약 현황 표시
- **실패 시**: TypeScript 타입 기반 구체적인 오류 메시지, 전체 현황 페이지로 복귀
- **내 예약 조회 페이지로의 이동 옵션 제공**

### 엣지케이스 대응
- 페이지 로딩 중 다른 사용자의 예약으로 인한 현황 변경
- 예약 진행 중 다른 사용자가 같은 시간 예약 완료 시
- 네트워크 오류로 인한 중복 제출 방지 (TypeScript + React Hook Form)
- 전체 현황 페이지에서 실시간 데이터 동기화 오류 처리

## 2. 내 예약 조회 (사용자)

### 입력 (사용자 상호작용)
1. 내 예약 조회 페이지 접근 (`app/my-reservations/page.tsx`)
2. 휴대폰번호 입력 (010-0000-0000 형식)
3. 비밀번호 입력
4. 조회 버튼 클릭
5. (조회 후) 특정 예약 선택하여 상세 정보 확인
6. (선택적) 예약 취소 버튼 클릭

### 처리 (시스템 내부 로직)
1. **입력된 휴대폰번호 형식 유효성 검증** (TypeScript + Zod)
   ```typescript
   const phoneSchema = z.string().regex(/^010-\d{4}-\d{4}$/, '올바른 휴대폰번호를 입력해주세요');
   ```

2. **휴대폰번호와 비밀번호 조합으로 예약 데이터 조회**
   ```typescript
   const reservations: Reservation[] = await reservationService.getMyReservations(phone, password);
   ```

3. **해당 휴대폰번호로 등록된 모든 예약 내역 검색**
4. **비밀번호 매칭 확인** (각 예약별로)
5. **조회된 예약 데이터 정렬** (최신순)
6. **(예약 취소 시) 취소 가능 시간 확인 및 상태 업데이트**

### 출력 (사용자 피드백)
- **성공 시**: 매칭된 예약 목록 표시 (회의실명, 예약일시, 예약자명, 상태)
- **예약 없음**: "해당 정보로 등록된 예약이 없습니다" 메시지
- **인증 실패**: "입력하신 정보와 일치하는 예약이 없습니다" 메시지
- **예약 상세**: 선택한 예약의 모든 정보 표시
- **취소 완료**: 취소 확인 메시지 및 업데이트된 예약 목록

### 엣지케이스 대응
- 잘못된 휴대폰번호 형식 입력 (Zod 스키마로 검증)
- 존재하지 않는 휴대폰번호 입력
- 올바른 휴대폰번호이지만 잘못된 비밀번호
- 동일 휴대폰번호로 여러 예약이 있지만 각기 다른 비밀번호
- 이미 지난 예약에 대한 취소 시도
- 네트워크 오류로 인한 조회 실패

## 3. 관리자 - 회의실 등록

### 입력 (사용자 상호작용)
1. 관리자 페이지 접근 (`app/admin/page.tsx`)
2. "새 회의실 등록" 버튼 클릭
3. 회의실 정보 입력
   - 회의실 이름 입력
   - 회의실 위치 입력
   - 수용 가능 인원수 입력
4. 등록 버튼 클릭

### 처리 (시스템 내부 로직)
1. **관리자 권한 확인** (단순 페이지 접근 기반)
2. **입력 데이터 유효성 검증** (Zod 스키마)
   ```typescript
   const roomSchema = z.object({
     name: z.string().min(1, '회의실 이름을 입력해주세요'),
     location: z.string().min(1, '회의실 위치를 입력해주세요'),
     capacity: z.number().min(1, '수용 인원은 1명 이상이어야 합니다')
   });
   ```

3. **회의실 이름 중복 확인** (UNIQUE 제약조건)
4. **필수 필드 입력 확인**
5. **수용 인원 숫자 형식 확인**
6. **회의실 데이터 Supabase 저장**
   ```typescript
   const result: ServiceResult<Room> = await roomService.createRoom(roomData);
   ```

7. **회의실 고유 ID 자동 생성** (UUID)
8. **관리자 회의실 목록 데이터 갱신**

### 출력 (사용자 피드백)
- **성공 시**: "회의실이 성공적으로 등록되었습니다" 메시지
- **중복 오류**: "이미 존재하는 회의실 이름입니다" 메시지
- **입력 오류**: 구체적인 필드별 오류 메시지 표시 (TypeScript 타입 기반)
- **등록된 회의실이 포함된 전체 회의실 목록으로 이동**
- **방금 등록된 회의실 하이라이트 표시**

### 엣지케이스 대응
- 회의실 이름 중복 (대소문자, 공백 포함 유사성 검사)
- 특수문자나 너무 긴 이름 입력 (TypeScript string 타입 체크)
- 수용 인원에 음수나 0, 비현실적으로 큰 숫자 입력 (number 타입 + Zod 검증)
- 네트워크 오류로 인한 중복 등록 방지
- 필수 필드 누락 상태에서 등록 시도

## 4. 관리자 - 회의실 수정

### 입력 (사용자 상호작용)
1. 관리자 페이지의 회의실 목록에서 특정 회의실 선택
2. "수정" 버튼 클릭
3. 수정 모달에서 기존 정보 확인
4. 수정할 필드 변경
   - 회의실 이름 수정
   - 회의실 위치 수정
   - 수용 가능 인원수 수정
5. "수정 완료" 버튼 클릭

### 처리 (시스템 내부 로직)
1. **관리자 권한 확인**
2. **수정 대상 회의실 존재 여부 확인**
   ```typescript
   const room: Room | null = await roomService.getRoomById(roomId);
   ```

3. **변경된 데이터 유효성 검증** (TypeScript + Zod)
4. **회의실 이름 중복 확인** (다른 회의실과)
5. **해당 회의실에 기존 예약이 있는지 확인**
   ```typescript
   const hasActiveReservations = await reservationService.hasActiveReservations(roomId);
   ```

6. **Supabase 데이터베이스 업데이트 실행**
7. **관리자 회의실 목록 데이터 갱신**

### 출력 (사용자 피드백)
- **성공 시**: "회의실 정보가 성공적으로 수정되었습니다" 메시지
- **중복 오류**: "이미 존재하는 회의실 이름입니다" 메시지
- **기존 예약 주의**: "기존 예약에 영향을 줄 수 있습니다" 경고
- **수정된 회의실이 포함된 전체 목록으로 이동**
- **수정된 회의실 하이라이트 표시**

### 엣지케이스 대응
- 수정 중 다른 관리자가 동일 회의실 수정 시도 (낙관적 락킹)
- 회의실에 활성 예약이 있을 때 중요 정보(위치, 인원) 수정
- 존재하지 않는 회의실 ID로 수정 시도 (TypeScript UUID 타입 체크)

## 5. 관리자 - 회의실 삭제

### 입력 (사용자 상호작용)
1. 관리자 페이지의 회의실 목록에서 특정 회의실 선택
2. "삭제" 버튼 클릭
3. 삭제 확인 다이얼로그에서 "확인" 클릭
4. (기존 예약이 있을 경우) 추가 확인 메시지에서 "강제 삭제" 선택

### 처리 (시스템 내부 로직)
1. **관리자 권한 확인**
2. **삭제 대상 회의실 존재 여부 확인**
3. **해당 회의실의 기존 예약 현황 조회**
   ```typescript
   const reservationCount = await reservationService.getActiveReservationCount(roomId);
   ```

4. **예약이 있는 경우 관리자에게 경고 및 선택권 제공**
5. **관련 예약 데이터 처리** (CASCADE DELETE)
6. **회의실 데이터 Supabase에서 삭제**
   ```typescript
   const result: ServiceResult<void> = await roomService.deleteRoom(roomId);
   ```

7. **관리자 회의실 목록 데이터 갱신**

### 출력 (사용자 피드백)
- **예약 없음**: "회의실이 성공적으로 삭제되었습니다" 메시지
- **기존 예약 존재**: "X건의 예약이 있습니다. 정말 삭제하시겠습니까?" 경고
- **삭제 완료**: 관련 예약 처리 결과와 함께 완료 메시지
- **삭제 취소**: "삭제가 취소되었습니다" 메시지
- **업데이트된 회의실 목록 표시**

### 엣지케이스 대응
- 삭제 중 해당 회의실에 새로운 예약 생성 시도
- 존재하지 않는 회의실 ID로 삭제 시도
- 삭제 과정에서 네트워크 오류 발생
- 다른 관리자가 동시에 같은 회의실 삭제 시도

## 기술적 고려사항

### 핵심 기술 스택
- **Frontend**: Next.js 14+ (App Router), TypeScript
- **Backend**: Supabase (PostgreSQL)
- **Deployment**: Vercel
- **Styling**: Tailwind CSS + shadcn-ui
- **Real-time**: Supabase Realtime
- **Form Management**: React Hook Form + Zod
- **Date Handling**: date-fns
- **State Management**: React useState/useReducer

### App Router 구조
```typescript
// src/app/ 구조
src/app/
├── layout.tsx              # 루트 레이아웃
├── page.tsx                # 홈페이지 (예약 현황)
├── my-reservations/        # 내 예약 조회
│   └── page.tsx
└── admin/                  # 관리자 페이지
    └── page.tsx
```

### 구현 원칙
- **Over Engineering 방지**: 기본에 충실한 MVP 구현
- **모던하고 심플한 UI/UX**: Apple 스타일 디자인
- **동시성 처리**: PostgreSQL GIST 제약조건 활용
- **데이터 일관성 보장**: 외래키 제약 및 트랜잭션
- **실시간 동기화**: Supabase Realtime 활용
- **타입 안전성**: TypeScript + Zod 활용

### 데이터플로우 (간략)

#### 1. 회의실 데이터 흐름
```typescript
// 생성
const createResult: ServiceResult<Room> = await roomService.createRoom(roomData);

// 조회
const rooms: Room[] = await roomService.getAllRooms();

// 수정 (기존 예약 확인)
const updateResult: ServiceResult<Room> = await roomService.updateRoom(id, updateData);

// 삭제 (CASCADE DELETE)
const deleteResult: ServiceResult<void> = await roomService.deleteRoom(id);
```

#### 2. 예약 데이터 흐름
```typescript
// 생성 (중복 시간 확인)
const createResult: ServiceResult<Reservation> = await reservationService.createReservation(data);

// 조회 (휴대폰번호+비밀번호 필터링)
const myReservations: Reservation[] = await reservationService.getMyReservations(phone, password);

// 전체 현황 (JOIN 쿼리)
const roomsWithReservations: RoomWithReservations[] = await reservationService.getReservationsByDate(date);

// 취소 (status UPDATE)
const cancelResult: ServiceResult<void> = await reservationService.cancelReservation(id, phone, password);
```

#### 3. 실시간 동기화
```typescript
// 예약 생성/취소 → 전체 현황 페이지 업데이트
const subscription = supabase
  .channel('reservations')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'reservations'
  }, (payload: RealtimePostgresChangesPayload<Reservation>) => {
    // TypeScript 타입 안전성 보장된 업데이트
    updateReservationState(payload);
  })
  .subscribe();

// 회의실 수정/삭제 → 관련 예약 데이터 처리
const roomSubscription = supabase
  .channel('meeting_rooms')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'meeting_rooms'
  }, handleRoomUpdate)
  .subscribe();
```

### TypeScript 타입 안전성
```typescript
// 강타입 인터페이스 정의
interface ReservationFormData {
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
}

// Zod 스키마를 통한 런타임 검증
const reservationSchema = z.object({
  reserver_name: z.string().min(1, '예약자 이름을 입력해주세요'),
  reserver_phone: z.string().regex(/^010-\d{4}-\d{4}$/, '올바른 휴대폰번호를 입력해주세요'),
  reserver_password: z.string().min(4, '비밀번호는 4자리 이상 입력해주세요'),
  reservation_date: z.string(),
  start_time: z.string(),
  end_time: z.string(),
});

// 타입 추론 및 검증
export type ReservationFormData = z.infer<typeof reservationSchema>;

export function validateReservationData(data: unknown): ReservationFormData {
  return reservationSchema.parse(data);
}
```

### 서버/클라이언트 컴포넌트 구조
```typescript
// 서버 컴포넌트 (기본) - 데이터 패칭
export default async function ReservationPage() {
  const rooms: Room[] = await roomService.getAllRooms();
  const reservations: RoomWithReservations[] = await reservationService.getReservationsByDate(new Date());
  
  return <ReservationCalendar rooms={rooms} initialReservations={reservations} />;
}

// 클라이언트 컴포넌트 (상호작용 필요시)
'use client';
export function ReservationForm({ roomId }: { roomId: string }) {
  const [formData, setFormData] = useState<ReservationFormData>({
    reserver_name: '',
    reserver_phone: '',
    reserver_password: '',
    reservation_date: '',
    start_time: '',
    end_time: '',
  });
  
  const handleSubmit = async (data: ReservationFormData) => {
    const validatedData = validateReservationData(data);
    const result = await reservationService.createReservation({
      ...validatedData,
      room_id: roomId,
    });
    // 결과 처리
  };
  
  // JSX 반환
}
```

### 에러 처리 및 사용자 피드백
```typescript
// 타입 안전한 에러 처리
interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// 컴포넌트에서 에러 처리
const [error, setError] = useState<string | null>(null);
const [loading, setLoading] = useState(false);

const handleAction = async () => {
  setLoading(true);
  setError(null);
  
  try {
    const result: ServiceResult<Reservation> = await reservationService.createReservation(data);
    
    if (!result.success) {
      setError(result.error || '작업에 실패했습니다');
      return;
    }
    
    // 성공 처리
    toast.success('예약이 완료되었습니다');
  } catch (error) {
    setError(error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다');
  } finally {
    setLoading(false);
  }
};
```

이 유저플로우는 TypeScript와 Next.js App Router를 기반으로 한 안정적이고 사용자 친화적인 회의실 관리 시스템 구현을 위한 상세하고 실용적인 가이드라인을 제공합니다.
</file>

<file path="eslint.config.mjs">
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
  {
    rules: {
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="src/app/admin/login/page.tsx">
'use client';

import { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';

export default function AdminLoginPage() {
  const [token, setToken] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const login = async () => {
    setLoading(true);
    setError(null);
    const res = await fetch('/api/admin/auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token }),
    });
    setLoading(false);
    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      setError(j.error || '로그인 실패');
      return;
    }
    window.location.href = '/admin';
  };

  return (
    <div className="max-w-md mx-auto p-6">
      <h1 className="text-2xl font-semibold mb-4">관리자 로그인</h1>
      <Card className="p-4 space-y-3">
        <div className="space-y-1">
          <Label htmlFor="token">관리자 토큰</Label>
          <Input id="token" value={token} onChange={(e) => setToken(e.target.value)} type="password" />
        </div>
        {error && <p className="text-sm text-red-600">{error}</p>}
        <div className="flex justify-end">
          <Button onClick={login} disabled={loading}>{loading ? '로그인 중...' : '로그인'}</Button>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/page.tsx">
'use client';

import { useEffect, useState, useCallback } from 'react';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { createClient } from '@/lib/supabase/client';

interface RoomForm { id?: string; name: string; location: string; capacity: number }

export default function AdminPage() {
  const [rooms, setRooms] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [unauthorized, setUnauthorized] = useState(false);
  const [form, setForm] = useState<RoomForm>({ name: '', location: '', capacity: 4 });

  const load = useCallback(async () => {
    setLoading(true);
    const res = await fetch('/api/admin/rooms');
    const json = await res.json();
    setLoading(false);
    if (res.status === 401) {
      setUnauthorized(true);
      return;
    }
    if (!res.ok) return alert(json.error || '불러오기 실패');
    setRooms(json.data);
  }, []);

  useEffect(() => { load(); }, [load]);

  // Realtime subscription
  useEffect(() => {
    const supabase = createClient();
    const channel = supabase
      .channel('meeting_rooms:realtime')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'meeting_rooms' }, () => {
        load();
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [load]);

  const submit = async () => {
    const method = form.id ? 'PUT' : 'POST';
    const res = await fetch('/api/admin/rooms', {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(form),
    });
    const json = await res.json();
    if (!res.ok) return alert(json.error || '저장 실패');
    setForm({ name: '', location: '', capacity: 4 });
    load();
  };

  const remove = async (id: string) => {
    if (!confirm('삭제하시겠습니까? 관련 예약이 함께 삭제됩니다.')) return;
    const res = await fetch('/api/admin/rooms?id=' + id, { method: 'DELETE' });
    const json = await res.json();
    if (!res.ok) return alert(json.error || '삭제 실패');
    load();
  };

  return (
    <div className="max-w-4xl mx-auto p-6 space-y-6">
      <h1 className="text-2xl font-semibold">관리자 - 회의실 관리</h1>
      {unauthorized && (
        <Card className="p-4 text-sm">
          관리자 권한이 필요합니다. <a className="underline" href="/admin/login">로그인 페이지로 이동</a>
        </Card>
      )}

      <Card className="p-4 space-y-3">
        <h2 className="font-medium">회의실 생성/수정</h2>
        <div className="grid md:grid-cols-3 gap-3">
          <div className="space-y-1">
            <Label htmlFor="room-name">이름</Label>
            <Input id="room-name" value={form.name} onChange={(e) => setForm({ ...form, name: e.target.value })} />
          </div>
          <div className="space-y-1">
            <Label htmlFor="room-location">위치</Label>
            <Input id="room-location" value={form.location} onChange={(e) => setForm({ ...form, location: e.target.value })} />
          </div>
          <div className="space-y-1">
            <Label htmlFor="room-capacity">수용 인원</Label>
            <Input id="room-capacity" type="number" value={form.capacity} onChange={(e) => setForm({ ...form, capacity: Number(e.target.value || 0) })} />
          </div>
        </div>
        <div className="flex gap-2">
          <Button onClick={submit} data-testid="submit-button">{form.id ? '수정' : '생성'}</Button>
          {form.id && <Button variant="secondary" onClick={() => setForm({ name: '', location: '', capacity: 4 })}>취소</Button>}
        </div>
      </Card>

      <Card className="p-4 space-y-3">
        <h2 className="font-medium">회의실 목록</h2>
        {loading ? (
          <p className="text-sm text-muted-foreground">불러오는 중...</p>
        ) : unauthorized ? (
          <p className="text-sm text-muted-foreground">권한이 없습니다.</p>
        ) : (
          <ul className="divide-y">
            {rooms.map((r: any) => (
              <li key={r.id} className="flex items-center justify-between py-2">
                <div className="text-sm">
                  <div className="font-medium">{r.name}</div>
                  <div className="text-muted-foreground">{r.location} · {r.capacity}인</div>
                </div>
                <div className="flex gap-2">
                  <Button variant="secondary" onClick={() => setForm({ id: r.id, name: r.name, location: r.location, capacity: r.capacity })}>수정</Button>
                  <Button variant="destructive" onClick={() => remove(r.id)}>삭제</Button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </Card>
    </div>
  );
}
</file>

<file path="src/app/api/admin/auth/route.ts">
import 'server-only';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(req: NextRequest) {
  const { token } = await req.json().catch(() => ({ token: undefined }));
  const expected = process.env.ADMIN_TOKEN;
  if (!expected) return NextResponse.json({ error: 'Server misconfigured' }, { status: 500 });
  if (!token || token !== expected) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  const res = NextResponse.json({ ok: true });
  res.cookies.set('admin_token', expected, {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    path: '/',
    maxAge: 60 * 60 * 8, // 8 hours
  });
  return res;
}

export async function DELETE() {
  const res = NextResponse.json({ ok: true });
  res.cookies.set('admin_token', '', { httpOnly: true, maxAge: 0, path: '/' });
  return res;
}
</file>

<file path="src/app/api/admin/rooms/route.ts">
import 'server-only';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServiceClient } from '@/lib/supabase/service';
import { requireAdmin } from '@/lib/auth/admin';

const createSchema = z.object({
  name: z.string().min(1),
  location: z.string().min(1),
  capacity: z.number().int().positive(),
});

export async function GET(req: NextRequest) {
  const unauth = requireAdmin(req);
  if (unauth) return unauth;
  const supabase = createServiceClient();
  const { data, error } = await supabase.from('meeting_rooms').select('*').order('name');
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ data });
}

export async function POST(req: NextRequest) {
  const unauth = requireAdmin(req);
  if (unauth) return unauth;
  const payload = await req.json();
  const parsed = createSchema.safeParse(payload);
  if (!parsed.success) return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  const supabase = createServiceClient();
  const { data, error } = await supabase.from('meeting_rooms').insert(parsed.data).select('*').single();
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ data }, { status: 201 });
}

export async function PUT(req: NextRequest) {
  const unauth = requireAdmin(req);
  if (unauth) return unauth;
  const payload = await req.json();
  const schema = createSchema.extend({ id: z.string().uuid() });
  const parsed = schema.safeParse(payload);
  if (!parsed.success) return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  const { id, ...updates } = parsed.data;
  const supabase = createServiceClient();
  const { data, error } = await supabase.from('meeting_rooms').update(updates).eq('id', id).select('*').single();
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ data });
}

export async function DELETE(req: NextRequest) {
  const unauth = requireAdmin(req);
  if (unauth) return unauth;
  const { searchParams } = new URL(req.url);
  const id = searchParams.get('id');
  if (!id) return NextResponse.json({ error: 'id is required' }, { status: 400 });
  const supabase = createServiceClient();
  const { error } = await supabase.from('meeting_rooms').delete().eq('id', id);
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ ok: true });
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import './globals.css';
import Providers from './providers';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/my-reservations/page.tsx">
'use client';

import { useState } from 'react';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { getMyReservations, cancelReservation } from '@/lib/services/reservations';

export default function MyReservationsPage() {
  const { toast } = useToast();
  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [items, setItems] = useState<any[]>([]);

  const handleSearch = async () => {
    setLoading(true);
    const res = await getMyReservations(phone, password);
    setLoading(false);
    if (!res.success) return toast({ description: res.error, variant: 'destructive' });
    setItems(res.data ?? []);
    if ((res.data ?? []).length === 0) toast({ description: '예약 내역이 없습니다.' });
  };

  const handleCancel = async (id: string) => {
    const res = await cancelReservation(id, phone, password);
    if (!res.success) return toast({ description: res.error, variant: 'destructive' });
    toast({ description: '예약이 취소되었습니다.' });
    handleSearch();
  };

  return (
    <div className="max-w-3xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-semibold">내 예약 조회</h1>

      <Card className="p-4 space-y-3">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <div className="space-y-1">
            <Label htmlFor="phone">전화번호</Label>
            <Input id="phone" value={phone} onChange={(e) => setPhone(e.target.value)} placeholder="010-0000-0000" />
          </div>
          <div className="space-y-1">
            <Label htmlFor="password">비밀번호</Label>
            <Input id="password" type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
          </div>
        </div>
        <div className="flex justify-end">
          <Button onClick={handleSearch} disabled={loading}>{loading ? '조회 중...' : '조회'}</Button>
        </div>
      </Card>

      {items.length > 0 && (
        <Card className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">총 {items.length}건</p>
          <ul className="space-y-2">
            {items.map((r) => (
              <li key={r.id} className="flex items-center justify-between border rounded p-2">
                <div className="text-sm">
                  <div className="font-medium">{r.reservation_date} · {r.start_time?.slice(0,5)}~{r.end_time?.slice(0,5)}</div>
                  <div className="text-muted-foreground">상태: {r.status}</div>
                </div>
                {r.status === 'active' && (
                  <Button variant="secondary" onClick={() => handleCancel(r.id)}>취소</Button>
                )}
              </li>
            ))}
          </ul>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
// In Next.js, this file would be called: app/providers.tsx
'use client';

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query';
import { ThemeProvider } from 'next-themes';

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </ThemeProvider>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChangeEvent, useRef } from "react";

interface FileUploadProps extends React.HTMLAttributes<HTMLDivElement> {
  onFileChange: (file: File) => void;
  accept?: string;
}

export function FileUpload({
  className,
  onFileChange,
  accept = "image/*",
  children,
  ...props
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onFileChange(file);
    }
  };

  return (
    <div
      onClick={handleClick}
      className={cn(
        "cursor-pointer rounded-md border-2 border-dashed border-gray-300 p-4 hover:border-gray-400",
        className
      )}
      {...props}
    >
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/lib/auth/admin.ts">
import { NextRequest, NextResponse } from 'next/server';

function getProvidedToken(req: NextRequest) {
  const header = req.headers.get('x-admin-token');
  if (header) return header.trim();
  const auth = req.headers.get('authorization');
  if (!auth) return null;
  const m = auth.match(/^Bearer\s+(.*)$/i);
  return m ? m[1].trim() : null;
}

export function requireAdmin(req: NextRequest): NextResponse | null {
  const expected = process.env.ADMIN_TOKEN;
  if (!expected) {
    return NextResponse.json(
      { error: 'Server misconfigured: ADMIN_TOKEN not set' },
      { status: 500 }
    );
  }
  const token = getProvidedToken(req) || req.cookies.get('admin_token')?.value;
  if (!token || token !== expected) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  return null;
}
</file>

<file path="src/lib/services/reservations.ts">
import { createClient } from '@/lib/supabase/client';
import type { CreateReservationData, ServiceResult, Reservation } from '@/types';

export async function createReservation(
  data: CreateReservationData
): Promise<ServiceResult<string>> {
  const supabase = createClient();
  const { data: row, error } = await supabase.rpc('create_reservation', {
    p_room_id: data.room_id,
    p_date: data.reservation_date,
    p_start: data.start_time,
    p_end: data.end_time,
    p_name: data.reserver_name,
    p_phone: data.reserver_phone,
    p_password: data.reserver_password,
  });

  if (error) {
    return { success: false, error: error.message };
  }
  return { success: true, data: row?.id ?? '' };
}

export async function cancelReservation(
  id: string,
  phone: string,
  password: string
): Promise<ServiceResult<void>> {
  const supabase = createClient();
  const { error } = await supabase.rpc('cancel_reservation', {
    p_id: id,
    p_phone: phone,
    p_password: password,
  });
  if (error) return { success: false, error: error.message };
  return { success: true };
}

export async function getMyReservations(
  phone: string,
  password: string
): Promise<ServiceResult<Reservation[]>> {
  const supabase = createClient();
  const { data, error } = await supabase.rpc('get_my_reservations', {
    p_phone: phone,
    p_password: password,
  });
  if (error) return { success: false, error: error.message };
  return { success: true, data: (data ?? []) as Reservation[] };
}
</file>

<file path="src/lib/services/rooms.ts">
import { createClient } from '@/lib/supabase/client';
import type { Room, RoomWithReservations, Reservation } from '@/types';

export async function getRooms(): Promise<Room[]> {
  const supabase = createClient();
  const { data, error } = await supabase
    .from('meeting_rooms')
    .select('*')
    .order('name');
  if (error) throw error;
  return data as Room[];
}

export async function getReservationsByDate(
  date: string
): Promise<Reservation[]> {
  const supabase = createClient();
  // Use public view limited to safe columns
  const { data, error } = await supabase
    .from('public_reservations')
    .select('*')
    .eq('reservation_date', date);
  if (error) throw error;
  return data as unknown as Reservation[];
}

export async function getRoomsWithReservationsByDate(
  date: string
): Promise<RoomWithReservations[]> {
  const [rooms, reservations] = await Promise.all([
    getRooms(),
    getReservationsByDate(date),
  ]);
  const byRoom = new Map<string, Reservation[]>();
  reservations.forEach((r) => {
    const list = byRoom.get(r.room_id) ?? [];
    list.push(r);
    byRoom.set(r.room_id, list);
  });
  return rooms.map((room) => ({
    ...room,
    reservations: (byRoom.get(room.id) ?? []).sort((a, b) =>
      a.start_time.localeCompare(b.start_time)
    ),
  }));
}
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!url || !/^https?:\/\//.test(url)) {
    throw new Error(
      "Missing or invalid NEXT_PUBLIC_SUPABASE_URL. Set it to your https://<project>.supabase.co URL in .env.local or your hosting environment."
    );
  }
  if (!anonKey) {
    throw new Error(
      "Missing NEXT_PUBLIC_SUPABASE_ANON_KEY. Copy the anon key from Supabase project settings into .env.local or your hosting environment."
    );
  }

  return createBrowserClient(url, anonKey);
}
</file>

<file path="src/lib/supabase/service.ts">
import 'server-only';
import { createClient } from '@supabase/supabase-js';

export function createServiceClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY!;
  if (!url || !key) {
    throw new Error('Missing SUPABASE env (URL or SERVICE_ROLE_KEY)');
    }
  return createClient(url, key, { auth: { persistSession: false } });
}
</file>

<file path="src/middleware.ts">
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';

export function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;
  if (pathname.startsWith('/admin') && !pathname.startsWith('/admin/login')) {
    const token = req.cookies.get('admin_token')?.value;
    if (!token) {
      const url = req.nextUrl.clone();
      url.pathname = '/admin/login';
      url.searchParams.set('next', pathname);
      return NextResponse.redirect(url);
    }
  }
  return NextResponse.next();
}

export const config = {
  matcher: ['/admin/:path*'],
};
</file>

<file path="src/types/database.ts">
// Auto-derived from TRD docs; mirrors granted columns
export interface Database {
  public: {
    Tables: {
      meeting_rooms: {
        Row: {
          id: string;
          name: string;
          location: string;
          capacity: number;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          name: string;
          location: string;
          capacity: number;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          name?: string;
          location?: string;
          capacity?: number;
          created_at?: string;
          updated_at?: string;
        };
      };
      reservations: {
        Row: {
          id: string;
          room_id: string;
          reservation_date: string; // YYYY-MM-DD
          start_time: string; // HH:MM:SS
          end_time: string; // HH:MM:SS
          // Sensitive columns like phone/password are intentionally omitted
          status: 'active' | 'cancelled';
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          room_id: string;
          reservation_date: string;
          start_time: string;
          end_time: string;
          // reserver_name / phone / password are supplied via RPC
          status?: 'active' | 'cancelled';
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          room_id?: string;
          reservation_date?: string;
          start_time?: string;
          end_time?: string;
          status?: 'active' | 'cancelled';
          created_at?: string;
          updated_at?: string;
        };
      };
    };
  };
}
</file>

<file path="src/types/index.ts">
import type { Database } from './database';

export type Room = Database['public']['Tables']['meeting_rooms']['Row'];
export type Reservation = Database['public']['Tables']['reservations']['Row'];

export interface CreateRoomData {
  name: string;
  location: string;
  capacity: number;
}

export interface CreateReservationData {
  room_id: string;
  reservation_date: string; // YYYY-MM-DD
  start_time: string; // HH:MM:SS
  end_time: string; // HH:MM:SS
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
}

export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface TimeSlot {
  start: string; // HH:MM
  end: string; // HH:MM
}

export interface RoomWithReservations extends Room {
  reservations: Reservation[];
}
</file>

<file path="supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "dbtest2"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) — enables hot reload during local development.
# `oneshot` — fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="supabase/migrations/20250915000000_initial_schema.sql">
-- 1. 확장 활성화 (btree_gist)
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- 2. 테이블 생성 (meeting_rooms, reservations)
CREATE TABLE IF NOT EXISTS meeting_rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    location VARCHAR(200) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE,
    reservation_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    reserver_phone VARCHAR(20) NOT NULL,
    reserver_password VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. 제약조건 추가 (GIST)
ALTER TABLE reservations
ADD CONSTRAINT no_overlapping_reservations
EXCLUDE USING GIST (
    room_id WITH =,
    reservation_date WITH =,
    tsrange(
        (reservation_date::timestamp + start_time),
        (reservation_date::timestamp + end_time)
    ) WITH &&
) WHERE (status = 'active');

-- 4. 인덱스 생성 (성능 최적화)
CREATE INDEX IF NOT EXISTS idx_reservations_phone ON reservations(reserver_phone);
CREATE INDEX IF NOT EXISTS idx_reservations_date_room ON reservations(reservation_date, room_id, status);
CREATE INDEX IF NOT EXISTS idx_meeting_rooms_name ON meeting_rooms(name);

-- 5. RLS 비활성화
ALTER TABLE meeting_rooms DISABLE ROW LEVEL SECURITY;
ALTER TABLE reservations DISABLE ROW LEVEL SECURITY;

-- 6. 트리거 함수 생성 (updated_at 자동화)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_meeting_rooms_updated_at
    BEFORE UPDATE ON meeting_rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_reservations_updated_at
    BEFORE UPDATE ON reservations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- 7. PostgreSQL 함수 생성 (중복 확인)
CREATE OR REPLACE FUNCTION check_time_conflict(
    p_room_id UUID,
    p_date DATE,
    p_start_time TIME,
    p_end_time TIME
)
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)::INTEGER
        FROM reservations 
        WHERE room_id = p_room_id 
        AND reservation_date = p_date 
        AND status = 'active'
        AND tsrange(
                (p_date::timestamp + p_start_time),
                (p_date::timestamp + p_end_time)
            ) && tsrange(
                (reservation_date::timestamp + start_time),
                (reservation_date::timestamp + end_time)
            )
    );
END;
$$ LANGUAGE plpgsql;

-- 8. 더미 데이터 삽입
INSERT INTO meeting_rooms (name, location, capacity) VALUES
('휴게실 A', '1층 동쪽', 4),
('휴게실 B', '1층 서쪽', 6),
('휴게실 C', '2층 중앙', 8),
('휴게실 D', '2층 북쪽', 4),
('휴게실 E', '3층 남쪽', 10)
ON CONFLICT (name) DO NOTHING;
</file>

<file path="supabase/migrations/20250915130455_create_users_table.sql">
-- supabase/migrations/[날짜]_create_users_table.sql
CREATE TABLE users (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  email text UNIQUE NOT NULL,
  name text NOT NULL,
  created_at timestamp with time zone DEFAULT now()
);
</file>

<file path="supabase/migrations/20250915223000_add_reservations_end_after_start_check.sql">
-- Ensure an individual reservation has an end time after the start time
ALTER TABLE reservations
ADD CONSTRAINT reservations_end_after_start
CHECK (end_time > start_time);
</file>

<file path="supabase/migrations/20250915224000_enable_rls_and_index.sql">
-- Enable RLS and add baseline policies and an extra index

-- 1) Enable Row Level Security
ALTER TABLE meeting_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE reservations ENABLE ROW LEVEL SECURITY;

-- 2) Meeting rooms: allow read to all clients
CREATE POLICY meeting_rooms_select_all
  ON meeting_rooms
  FOR SELECT
  TO authenticated, anon
  USING (true);

-- 3) Reservations policies
-- Allow read to all clients (availability lookups, etc.)
CREATE POLICY reservations_select_all
  ON reservations
  FOR SELECT
  TO authenticated, anon
  USING (true);

-- Allow inserts from all clients (public booking)
CREATE POLICY reservations_insert_all
  ON reservations
  FOR INSERT
  TO authenticated, anon
  WITH CHECK (true);

-- Restrict updates and deletes to service role only
-- Note: auth.role() is available on Supabase; fallback to JWT role claim check.
CREATE POLICY reservations_update_service_only
  ON reservations
  FOR UPDATE
  TO authenticated, anon
  USING (coalesce(auth.role(), (current_setting('request.jwt.claims', true)::jsonb ->> 'role')) = 'service_role')
  WITH CHECK (coalesce(auth.role(), (current_setting('request.jwt.claims', true)::jsonb ->> 'role')) = 'service_role');

CREATE POLICY reservations_delete_service_only
  ON reservations
  FOR DELETE
  TO authenticated, anon
  USING (coalesce(auth.role(), (current_setting('request.jwt.claims', true)::jsonb ->> 'role')) = 'service_role');

-- 4) Performance index for time-range lookups
CREATE INDEX IF NOT EXISTS idx_reservations_room_date_time
  ON reservations(room_id, reservation_date, start_time, end_time);
</file>

<file path="supabase/migrations/20250915230000_security_hardening.sql">
-- Security hardening (without pgcrypto): column grants, RPCs, public view

-- 1) Column-level access: restrict sensitive columns on reservations
REVOKE ALL ON TABLE reservations FROM PUBLIC;
GRANT SELECT (id, room_id, reservation_date, start_time, end_time, status, created_at, updated_at)
  ON reservations TO anon, authenticated;

-- 2) Lock down direct INSERT from clients; use RPC instead
DROP POLICY IF EXISTS reservations_insert_all ON reservations;

-- 3) RPCs for create and cancel (store plain password; restrict read via column grants)
CREATE OR REPLACE FUNCTION public.create_reservation(
  p_room_id UUID,
  p_date DATE,
  p_start TIME,
  p_end TIME,
  p_name TEXT,
  p_phone TEXT,
  p_password TEXT
) RETURNS reservations AS $$
DECLARE
  r reservations;
BEGIN
  IF p_end <= p_start THEN
    RAISE EXCEPTION 'end_time must be greater than start_time' USING ERRCODE = '22023';
  END IF;

  INSERT INTO reservations (
    room_id, reservation_date, start_time, end_time,
    reserver_name, reserver_phone, reserver_password, status
  ) VALUES (
    p_room_id, p_date, p_start, p_end,
    p_name, p_phone, p_password, 'active'
  ) RETURNING * INTO r;

  RETURN r;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.create_reservation(UUID, DATE, TIME, TIME, TEXT, TEXT, TEXT)
  TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.cancel_reservation(
  p_id UUID,
  p_phone TEXT,
  p_password TEXT
) RETURNS VOID AS $$
BEGIN
  UPDATE reservations
  SET status = 'cancelled'
  WHERE id = p_id
    AND reserver_phone = p_phone
    AND reserver_password = p_password
    AND status = 'active';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'invalid reservation info or already cancelled' USING ERRCODE = '22023';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.cancel_reservation(UUID, TEXT, TEXT)
  TO anon, authenticated;

-- 4) Public view with safe columns only
CREATE OR REPLACE VIEW public.public_reservations AS
SELECT id, room_id, reservation_date, start_time, end_time, status, created_at, updated_at
FROM reservations
WHERE status = 'active';

GRANT SELECT ON public.public_reservations TO anon, authenticated;
</file>

<file path="supabase/migrations/20250915231000_get_my_reservations_rpc.sql">
-- RPC to list reservations by phone+password returning safe columns only
CREATE OR REPLACE FUNCTION public.get_my_reservations(
  p_phone TEXT,
  p_password TEXT
) RETURNS TABLE (
  id UUID,
  room_id UUID,
  reservation_date DATE,
  start_time TIME,
  end_time TIME,
  reserver_name TEXT,
  status TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
) AS $$
  SELECT r.id, r.room_id, r.reservation_date, r.start_time, r.end_time,
         r.reserver_name, r.status, r.created_at, r.updated_at
  FROM reservations r
  WHERE r.reserver_phone = p_phone
    AND r.reserver_password = p_password
  ORDER BY r.reservation_date DESC, r.start_time DESC;
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.get_my_reservations(TEXT, TEXT)
  TO anon, authenticated;
</file>

<file path="supabase/migrations/20250915232000_enable_pgcrypto_and_hash_passwords.sql">
-- Enable password hashing and update RPCs to use hashes

-- 1) Enable pgcrypto
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2) Add password_hash column if not exists
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name='reservations' AND column_name='password_hash'
  ) THEN
    ALTER TABLE reservations ADD COLUMN password_hash TEXT;
  END IF;
END $$;

-- 3) Backfill from reserver_password if present
UPDATE reservations
SET password_hash = crypt(reserver_password, gen_salt('bf'))
WHERE password_hash IS NULL AND reserver_password IS NOT NULL;

-- 4) Replace create_reservation to store hashed password
CREATE OR REPLACE FUNCTION public.create_reservation(
  p_room_id UUID,
  p_date DATE,
  p_start TIME,
  p_end TIME,
  p_name TEXT,
  p_phone TEXT,
  p_password TEXT
) RETURNS reservations AS $$
DECLARE
  r reservations;
BEGIN
  IF p_end <= p_start THEN
    RAISE EXCEPTION 'end_time must be greater than start_time' USING ERRCODE = '22023';
  END IF;

  INSERT INTO reservations (
    room_id, reservation_date, start_time, end_time,
    reserver_name, reserver_phone, password_hash, status
  ) VALUES (
    p_room_id, p_date, p_start, p_end,
    p_name, p_phone, crypt(p_password, gen_salt('bf')), 'active'
  ) RETURNING * INTO r;

  RETURN r;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.create_reservation(UUID, DATE, TIME, TIME, TEXT, TEXT, TEXT)
  TO anon, authenticated;

-- 5) Replace cancel_reservation to verify hash
CREATE OR REPLACE FUNCTION public.cancel_reservation(
  p_id UUID,
  p_phone TEXT,
  p_password TEXT
) RETURNS VOID AS $$
BEGIN
  UPDATE reservations
  SET status = 'cancelled'
  WHERE id = p_id
    AND reserver_phone = p_phone
    AND password_hash = crypt(p_password, password_hash)
    AND status = 'active';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'invalid reservation info or already cancelled' USING ERRCODE = '22023';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.cancel_reservation(UUID, TEXT, TEXT)
  TO anon, authenticated;

-- 6) Update get_my_reservations to filter by hash
CREATE OR REPLACE FUNCTION public.get_my_reservations(
  p_phone TEXT,
  p_password TEXT
) RETURNS TABLE (
  id UUID,
  room_id UUID,
  reservation_date DATE,
  start_time TIME,
  end_time TIME,
  reserver_name TEXT,
  status TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
) AS $$
  SELECT r.id, r.room_id, r.reservation_date, r.start_time, r.end_time,
         r.reserver_name, r.status, r.created_at, r.updated_at
  FROM reservations r
  WHERE r.reserver_phone = p_phone
    AND r.password_hash = crypt(p_password, r.password_hash)
  ORDER BY r.reservation_date DESC, r.start_time DESC;
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION public.get_my_reservations(TEXT, TEXT)
  TO anon, authenticated;

-- 7) Optionally drop plain password column (safe once all code uses hash)
-- ALTER TABLE reservations DROP COLUMN IF EXISTS reserver_password;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss';

const config = {
  darkMode: ['class'],
  content: ['./src/**/*.{ts,tsx}'],
  prefix: '',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate'), require('@tailwindcss/typography')],
} satisfies Config;

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "strictNullChecks": false,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["vitest/globals"]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path=".cursor/rules/clean-code.mdc">
---
description: Clean Code Guidelines for Meeting Room System
globs: 
alwaysApply: true
---

# 회의실 관리 시스템 클린 코드 가이드라인

## 회의실 프로젝트에 특화된 실용적 클린 코드 원칙

### 핵심 원칙 (MVP 집중)
- **가독성 우선**: 복잡한 추상화보다 읽기 쉬운 코드
- **단순함**: DRY보다는 명확함 우선
- **실용성**: 이론적 완벽함보다 동작하는 코드
- **점진적 개선**: 기능 완성 후 리팩토링

## 네이밍 컨벤션

### 회의실 시스템 도메인 용어
```javascript
// 좋은 예시 - 도메인 용어 사용
const meetingRoom = { id, name, location, capacity };
const reservation = { roomId, date, startTime, endTime };
const reserverInfo = { name, phone, password };

// 나쁜 예시 - 일반적 용어
const data = { id, name, place, size };
const booking = { room, when, from, to };
const user = { name, contact, auth };
```

### 함수명은 동작을 명확히
```javascript
// 좋은 예시
function createReservation(reservationData) { }
function checkTimeConflict(roomId, date, timeRange) { }
function getMyReservations(phone, password) { }
function validateReservationForm(formData) { }

// 나쁜 예시  
function processData(data) { }
function handleSubmit(values) { }
function doCheck(params) { }
```

## 함수 작성 규칙 (회의실 시스템용)

### 단일 책임 원칙
```javascript
// 좋은 예시 - 하나의 책임
function isTimeSlotAvailable(roomId, date, startTime, endTime) {
  // 시간 중복 검사만 담당
}

function saveReservation(reservationData) {
  // 예약 저장만 담당  
}

// 나쁜 예시 - 여러 책임
function createReservationAndUpdateUI(data, setReservations) {
  // 비즈니스 로직 + UI 업데이트
}
```

### 함수 크기 제한
- **10줄 이내** 권장 (최대 20줄)
- 중첩 if문 최대 2단계
- 매개변수 최대 3개 (객체 사용 권장)

```javascript
// 좋은 예시
function validateReservationData({ name, phone, date, startTime, endTime }) {
  const errors = {};
  
  if (!name?.trim()) errors.name = '이름을 입력해주세요';
  if (!isValidPhone(phone)) errors.phone = '올바른 휴대폰번호를 입력해주세요';
  if (!isValidTimeRange(startTime, endTime)) errors.time = '시간을 확인해주세요';
  
  return errors;
}
```

## 컴포넌트 구조 (React 특화)

### 컴포넌트 분리 기준
```javascript
// 1. 화면별 컴포넌트 (pages)
function ReservationOverviewPage() { }
function MyReservationsPage() { }
function AdminPage() { }

// 2. 기능별 컴포넌트 (features)  
function ReservationForm() { }
function RoomList() { }
function ReservationCard() { }

// 3. 재사용 컴포넌트 (common)
function Modal() { }
function LoadingSpinner() { }
function ErrorMessage() { }
```

### Props 네이밍
```javascript
// 좋은 예시 - 명확한 의도
interface ReservationFormProps {
  selectedRoom: Room;
  selectedDate: Date;
  onReservationCreate: (reservation: Reservation) => void;
  onCancel: () => void;
}

// 나쁜 예시 - 모호한 의도
interface FormProps {
  data: any;
  onSubmit: (data: any) => void;
  onClose: () => void;
}
```

## 에러 처리 패턴

### 회의실 시스템 에러 처리
```javascript
// 서비스 레이어에서 에러 처리
async function createReservation(reservationData) {
  try {
    const { data, error } = await supabase
      .from('reservations')
      .insert(reservationData);
      
    if (error) {
      throw new Error(`예약 생성 실패: ${error.message}`);
    }
    
    return { success: true, data };
  } catch (error) {
    console.error('Reservation creation failed:', error);
    return { 
      success: false, 
      error: error.message || '예약 생성 중 오류가 발생했습니다' 
    };
  }
}

// 컴포넌트에서 에러 처리
function ReservationForm() {
  const [error, setError] = useState('');
  
  const handleSubmit = async (formData) => {
    const result = await createReservation(formData);
    
    if (!result.success) {
      setError(result.error);
      return;
    }
    
    // 성공 처리
  };
}
```

## 코드 구조화

### 파일 내부 구조 순서
```javascript
// 1. imports
import React, { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';

// 2. types/interfaces (TypeScript 사용시)
interface ReservationData {
  roomId: string;
  date: string;
  startTime: string;
  endTime: string;
}

// 3. constants
const TIME_SLOTS = ['09:00', '10:00', '11:00', '12:00'];

// 4. main component
export default function ReservationForm() {
  // state
  const [reservations, setReservations] = useState([]);
  
  // effects
  useEffect(() => {
    loadReservations();
  }, []);
  
  // handlers
  const handleSubmit = async (data) => {
    // 구현
  };
  
  // render
  return (
    // JSX
  );
}

// 5. helper functions (if needed)
function isValidTimeSlot(time) {
  return TIME_SLOTS.includes(time);
}
```

## 주석 및 문서화

### 언제 주석을 작성할까
```javascript
// 좋은 주석 - 비즈니스 로직 설명
function checkTimeConflict(existingReservations, newReservation) {
  // 동일 회의실, 동일 날짜에서 시간 겹침 확인
  // GIST 제약조건과 동일한 로직을 클라이언트에서도 검증
  return existingReservations.some(existing => 
    existing.roomId === newReservation.roomId &&
    existing.date === newReservation.date &&
    timeRangesOverlap(existing, newReservation)
  );
}

// 나쁜 주석 - 코드 중복 설명
function validatePhone(phone) {
  // 휴대폰번호가 비어있는지 확인
  if (!phone) return false;
  // 정규식으로 형식 확인  
  return /^010-\d{4}-\d{4}$/.test(phone);
}
```

## 성능 고려사항 (MVP용)

### 최소한의 최적화
```javascript
// React.memo 사용 - 불필요한 리렌더링 방지
const RoomCard = React.memo(function RoomCard({ room, onSelect }) {
  return <div onClick={() => onSelect(room)}>{room.name}</div>;
});

// useCallback 사용 - 핸들러 함수 최적화
const handleRoomSelect = useCallback((room) => {
  setSelectedRoom(room);
}, []);
```

## 실용적 리팩토링 규칙

### 리팩토링 시점
1. **같은 코드 3번 반복** → 함수로 추출
2. **컴포넌트 100줄 초과** → 분리 고려
3. **함수 20줄 초과** → 분리 고려
4. **중복 UI 패턴** → 공통 컴포넌트화

### 리팩토링 우선순위
1. **가독성 개선** (네이밍, 구조)
2. **중복 제거** (함수, 컴포넌트)
3. **에러 처리 강화**
4. **성능 최적화** (필요시)

## 최종 체크리스트

코드 작성 후 확인사항:
- [ ] 함수/변수명이 의도를 명확히 표현하는가?
- [ ] 함수가 하나의 책임만 가지는가?
- [ ] 에러 상황이 적절히 처리되는가?
- [ ] 사용자에게 명확한 피드백을 제공하는가?
- [ ] 코드가 회의실 도메인을 정확히 반영하는가?

**기억하세요**: 완벽한 코드보다는 **읽기 쉽고 동작하는 코드**가 우선입니다.
</file>

<file path=".cursor/rules/gistfile1.mdc">
---
description: ISMS-P Based Security Guidelines for Meeting Room System
globs: 
alwaysApply: true
---

# 회의실 관리 시스템 보안 가이드라인

본 문서는 ISMS-P 기반 보안 요구사항을 **회의실 관리 시스템 MVP**에 적합하도록 조정한 실용적 보안 가이드라인입니다.

## 시스템 특성 고려사항

**회의실 예약 시스템의 특성:**
- 내부 직원 대상 서비스 (제한적 사용자)
- 민감정보 최소화 (이름, 휴대폰번호만 수집)
- MVP 단순성 vs 보안 요구사항 균형
- Next.js + TypeScript + Supabase 기술 스택

## 1. 인증 및 권한 관리

### (A-1) 사용자 식별 및 인증 (MVP 적용)
- **MUST**: 예약자는 **휴대폰번호**로 개별 식별 가능해야 함
- **MUST**: 예약 비밀번호는 다음 정책 중 하나를 만족해야 함:
  - (a) **4자리 이상 숫자+문자 조합** (사용자 편의성 고려)
  - (b) 8자리 이상 문자, 숫자 조합
- **SHOULD**: 동일 휴대폰번호로 **연속 5회 실패 시 5분간 일시 제한** 구현

```typescript
// TypeScript 구현 예시
const passwordSchema = z.string()
  .min(4, '비밀번호는 4자리 이상 입력해주세요')
  .regex(/^(?=.*[A-Za-z])(?=.*\d)/, '영문과 숫자를 포함해야 합니다');

// 실패 횟수 추적 (메모리 기반 - MVP용)
const loginAttempts = new Map<string, { count: number; lastAttempt: Date }>();
```

### (A-2) 인증 정보 관리 (Supabase 적용)
- **MUST**: 예약 비밀번호는 **bcrypt** 해싱하여 저장
- **MUST**: Supabase의 암호화 기능 활용
- **MUST NOT**: 비밀번호 평문 저장 금지

```sql
-- Supabase에서 암호화 함수 사용
CREATE OR REPLACE FUNCTION hash_password(password text)
RETURNS text AS $$
BEGIN
  RETURN crypt(password, gen_salt('bf'));
END;
$$ LANGUAGE plpgsql;
```

### (A-3) 권한 관리 (단순화)
- **MUST**: **최소 권한 원칙** 적용
  - 일반 사용자: 예약 생성/조회/취소만
  - 관리자: 회의실 CRUD + 전체 예약 조회
- **MUST**: 권한 변경 시 **로그 기록** (Supabase 감사 로그 활용)

```typescript
// TypeScript 권한 체크
enum UserRole {
  USER = 'user',
  ADMIN = 'admin'
}

interface UserPermissions {
  canCreateReservation: boolean;
  canViewAllReservations: boolean;
  canManageRooms: boolean;
}

const getPermissions = (role: UserRole): UserPermissions => {
  switch (role) {
    case UserRole.USER:
      return {
        canCreateReservation: true,
        canViewAllReservations: false,
        canManageRooms: false
      };
    case UserRole.ADMIN:
      return {
        canCreateReservation: true,
        canViewAllReservations: true,
        canManageRooms: true
      };
  }
};
```

## 2. 접근 제어

### (AC-1) 시스템 접근 (Next.js + Vercel)
- **MUST**: 무단 접근 차단 (Vercel의 기본 보안 기능 활용)
- **MUST**: **중요 작업 로그 1년간 보관**
  - 예약 생성/수정/삭제
  - 관리자 회의실 관리 작업
  - 로그인 시도 (성공/실패)

### (AC-2) 네트워크 접근 (클라우드 환경)
- **MUST**: **Vercel의 기본 방화벽** 설정 유지
- **MUST**: **Supabase RLS 비활성화** (MVP 요구사항) 하되, 애플리케이션 레벨 접근 제어 구현
- **SHOULD**: 프로덕션에서는 **Vercel IP 화이트리스트** 고려

## 3. 암호화

### (C-1) 민감정보 암호화 (회의실 시스템 적용)
- **MUST**: **휴대폰번호 마스킹** 표시 (010-****-1234)
- **MUST**: **예약 비밀번호 해싱** 저장
- **MUST**: **HTTPS 통신** (Vercel 기본 제공)
- **회의실 시스템에서는 신용카드, 주민번호 등 수집하지 않으므로 해당 암호화 요구사항 제외**

```typescript
// 휴대폰번호 마스킹 유틸리티
export const maskPhoneNumber = (phone: string): string => {
  if (!/^010-\d{4}-\d{4}$/.test(phone)) return phone;
  return phone.replace(/(\d{3})-(\d{4})-(\d{4})/, '$1-****-$3');
};

// 사용 예시
const displayPhone = maskPhoneNumber(reservation.reserver_phone);
// 출력: "010-****-1234"
```

### (C-2) 암호화 키 관리 (Vercel + Supabase)
- **MUST**: **환경변수**로 키 관리 (Vercel Environment Variables)
- **MUST NOT**: 소스코드에 하드코딩 금지
- **MUST**: **Supabase 키 보안** 관리

```bash
# .env.local (개발환경)
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJxxx...
SUPABASE_SERVICE_ROLE_KEY=eyJxxx... # 서버에서만 사용

# Vercel 환경변수 설정 (프로덕션)
vercel env add NEXT_PUBLIC_SUPABASE_URL
vercel env add NEXT_PUBLIC_SUPABASE_ANON_KEY
```

## 4. 보안 개발

### (D-1) 보안 설계 (Next.js + TypeScript)
- **MUST**: **OWASP Top 10 대응** 설계
  - **SQL Injection**: Supabase ORM 사용
  - **XSS**: Next.js 기본 보호 + 입력 검증
  - **CSRF**: Next.js CSRF 토큰 사용

### (D-2) 보안 코딩 (TypeScript 강화)
- **MUST**: **모든 외부 입력 검증** (Zod 스키마 활용)
- **MUST**: **Parameterized Query** 사용 (Supabase 기본)
- **MUST**: **에러 정보 노출 금지** (프로덕션에서 스택 트레이스 숨김)

```typescript
// Zod를 활용한 입력 검증
const reservationInputSchema = z.object({
  reserver_name: z.string()
    .min(1, '이름을 입력해주세요')
    .max(50, '이름은 50자 이하로 입력해주세요')
    .regex(/^[가-힣a-zA-Z\s]+$/, '이름은 한글, 영문만 입력 가능합니다'),
  reserver_phone: z.string()
    .regex(/^010-\d{4}-\d{4}$/, '올바른 휴대폰번호를 입력해주세요'),
  reserver_password: z.string()
    .min(4, '비밀번호는 4자리 이상 입력해주세요')
    .max(20, '비밀번호는 20자리 이하로 입력해주세요'),
});

// 안전한 에러 처리
export function handleError(error: unknown): { message: string } {
  if (process.env.NODE_ENV === 'development') {
    console.error('Detailed error:', error);
  }
  
  return {
    message: error instanceof Error 
      ? '처리 중 오류가 발생했습니다' 
      : '알 수 없는 오류가 발생했습니다'
  };
}
```

### (D-3) 보안 테스트 (MVP 범위)
- **SHOULD**: **ESLint Security Plugin** 사용
- **SHOULD**: **TypeScript strict mode** 활성화
- **SHOULD**: 프로덕션 배포 전 **보안 체크리스트** 확인

```bash
# ESLint 보안 플러그인 설치
npm install --save-dev eslint-plugin-security

# .eslintrc.js 설정
{
  "extends": ["plugin:security/recommended"],
  "rules": {
    "security/detect-object-injection": "error",
    "security/detect-non-literal-regexp": "error"
  }
}
```

## 5. 개인정보 처리 (회의실 시스템 특화)

### (P-1) 수집 및 이용 (최소화 원칙)
- **MUST**: **최소 개인정보만 수집** (이름, 휴대폰번호, 비밀번호)
- **MUST**: 수집 목적 명시 및 동의 (회의실 예약 서비스 제공)
- **MUST NOT**: **불필요한 개인정보 수집 금지** (생년월일, 주소 등)

```typescript
// 최소 개인정보 인터페이스
interface ReservationPersonalInfo {
  reserver_name: string;      // 필수: 예약자 확인용
  reserver_phone: string;     // 필수: 예약 조회 키
  reserver_password: string;  // 필수: 예약 조회 인증
  // 추가 개인정보 수집 금지
}
```

### (P-2) 저장 및 표시 (마스킹)
- **MUST**: **휴대폰번호 마스킹** 표시 (010-****-1234)
- **MUST**: **비밀번호 해싱** 저장
- **MUST NOT**: 제3자 제공 금지 (내부 회의실 관리 목적만)

```typescript
// 안전한 예약 정보 표시
interface SafeReservationDisplay {
  id: string;
  room_name: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  masked_phone: string;        // 마스킹된 휴대폰번호
  status: ReservationStatus;
  // reserver_password는 표시하지 않음
}

export const toSafeDisplay = (reservation: Reservation): SafeReservationDisplay => ({
  ...reservation,
  masked_phone: maskPhoneNumber(reservation.reserver_phone),
  reserver_password: undefined, // 제거
});
```

### (P-3) 파기 (자동화)
- **MUST**: **예약 만료 후 자동 파기** (6개월 후)
- **MUST**: **파기 로그 기록**

```sql
-- Supabase에서 자동 파기 함수
CREATE OR REPLACE FUNCTION auto_delete_old_reservations()
RETURNS void AS $$
BEGIN
  DELETE FROM reservations 
  WHERE reservation_date < CURRENT_DATE - INTERVAL '6 months';
  
  INSERT INTO deletion_logs (table_name, deleted_count, deleted_at)
  VALUES ('reservations', ROW_COUNT, NOW());
END;
$$ LANGUAGE plpgsql;

-- 정기 실행 (Supabase Edge Functions)
SELECT cron.schedule('delete-old-reservations', '0 2 * * *', 'SELECT auto_delete_old_reservations();');
```

## 6. 로깅 및 관리

### (L-1) 로그 기록 (Next.js + Supabase)
- **MUST**: **중요 활동 로그 1년간 보관**
  - 예약 생성/수정/취소
  - 관리자 회의실 관리
  - 인증 시도 (성공/실패)
- **MUST**: 로그 표준화 (타임스탬프, 사용자 식별, IP, 작업, 결과)

```typescript
// 표준화된 로그 인터페이스
interface AuditLog {
  timestamp: string;           // ISO 8601 형식
  user_identifier: string;     // 휴대폰번호 (마스킹)
  source_ip: string;          // 클라이언트 IP
  action: string;             // 수행한 작업
  resource: string;           // 대상 리소스
  result: 'SUCCESS' | 'FAILURE'; // 결과
  details?: string;           // 추가 상세 정보
}

// 로그 기록 함수
export const logAuditEvent = async (event: Omit<AuditLog, 'timestamp'>) => {
  const auditLog: AuditLog = {
    ...event,
    timestamp: new Date().toISOString(),
    user_identifier: maskPhoneNumber(event.user_identifier),
  };
  
  await supabase.from('audit_logs').insert(auditLog);
};

// 사용 예시
await logAuditEvent({
  user_identifier: phone,
  source_ip: req.ip,
  action: 'CREATE_RESERVATION',
  resource: `room:${roomId}`,
  result: 'SUCCESS',
  details: `${date} ${startTime}-${endTime}`
});
```

## 7. MVP vs 프로덕션 보안 로드맵

### MVP 단계 (현재)
- ✅ 기본 입력 검증 (Zod)
- ✅ 비밀번호 해싱 (bcrypt)
- ✅ HTTPS 통신 (Vercel)
- ✅ 휴대폰번호 마스킹
- ✅ 기본 에러 처리

### 프로덕션 단계 (향후)
- 🔄 계정 잠금 정책 구현
- 🔄 상세 감사 로그 시스템
- 🔄 개인정보 자동 파기
- 🔄 보안 모니터링
- 🔄 정기 보안 점검

## 8. 보안 체크리스트

### 개발 시 확인사항
- [ ] 모든 외부 입력에 Zod 검증 적용
- [ ] 비밀번호 평문 저장 방지
- [ ] 휴대폰번호 마스킹 표시
- [ ] 에러 메시지에 내부 정보 노출 방지
- [ ] 환경변수로 민감정보 관리

### 배포 시 확인사항
- [ ] 프로덕션 환경변수 설정
- [ ] HTTPS 인증서 적용
- [ ] 로그 수집 설정
- [ ] 에러 추적 도구 연동
- [ ] 백업 정책 수립

## 9. 기술별 보안 구현

### Next.js 보안
```typescript
// next.config.js 보안 헤더
const nextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
        ],
      },
    ];
  },
};
```

### TypeScript 보안
```typescript
// 타입 안전한 환경변수 접근
const config = {
  supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
} as const;

// 런타임 환경변수 검증
const envSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
});

envSchema.parse(process.env);
```

### Supabase 보안
```sql
-- RLS 대신 애플리케이션 레벨 보안
-- 민감한 컬럼 암호화
CREATE TABLE reservations (
  id UUID PRIMARY KEY,
  reserver_phone_encrypted TEXT, -- 암호화된 휴대폰번호
  reserver_password_hash TEXT,   -- 해싱된 비밀번호
  -- 기타 필드들
);
```

이 보안 가이드라인은 **ISMS-P 요구사항과 MVP 현실성의 균형**을 맞춘 실용적 접근법을 제시합니다. 단계적으로 보안을 강화하면서 사용자 편의성과 개발 효율성을 유지할 수 있습니다.
</file>

<file path=".cursor/rules/git-commit-message.mdc">
---
description: Git Commit Rules for Meeting Room System
globs: 
alwaysApply: true
---

# Git Commit Message Rules

## Format Structure
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

## Types (Required)
- `feat`: new feature
- `fix`: bug fix
- `docs`: documentation only
- `style`: formatting, missing semi colons, etc
- `refactor`: code change that neither fixes bug nor adds feature
- `perf`: performance improvement
- `test`: adding missing tests
- `chore`: updating grunt tasks, dependencies, etc
- `ci`: changes to CI configuration
- `build`: changes affecting build system
- `revert`: reverting previous commit

## Scope (Optional) - Meeting Room System
- `reservation`: 예약 관련 기능
- `room`: 회의실 관리 기능
- `admin`: 관리자 기능
- `user`: 사용자 기능
- `db`: 데이터베이스 스키마
- `ui`: 사용자 인터페이스
- `api`: API 엔드포인트
- `auth`: 인증 관련
- Omit if change affects multiple areas

## Description Rules
- Use imperative mood: "add" not "added" or "adds"
- No capitalization of first letter
- No period at end
- Max 50 characters
- Be specific and actionable

## Body Guidelines
- Wrap at 72 characters
- Explain what and why, not how
- Separate from description with blank line
- Use bullet points for multiple changes

## Footer Format
- `BREAKING CHANGE:` for breaking changes
- `Closes #123` for issue references
- `Co-authored-by: Name <email>`

## Examples (Meeting Room System)
```
feat(reservation): add time conflict validation

fix(room): resolve duplicate room name issue

feat(admin): implement room deletion with warning

fix(user): correct phone number validation pattern

docs(db): update reservation schema documentation

style(ui): improve reservation form layout

refactor(api): extract room service functions

chore(deps): update supabase client to v2.38.0

feat(reservation): add real-time status updates

BREAKING CHANGE: change reservation phone field format
```

## Workflow Integration
**ALWAYS write a commit message after completing any development task, feature, or bug fix.**

## Validation Checklist
- [ ] Type is from approved list
- [ ] Description under 50 chars
- [ ] Imperative mood used
- [ ] No trailing period
- [ ] Meaningful and clear context
- [ ] Scope matches meeting room domain (if applicable)
</file>

<file path=".cursor/rules/global.mdc">
---
description: Simplified Guidelines for Meeting Room System
globs: 
alwaysApply: true
---

# 회의실 관리 시스템 개발 가이드라인

## Must

- **Next.js 14+ App Router 사용**: `app/` 디렉토리 구조 필수
- **TypeScript 사용**: 모든 파일에 .ts/.tsx 확장자 사용
- 컴포넌트는 필요시에만 client component 사용 (`'use client'` directive)
- page.tsx에서 params는 promise로 처리: `const { id } = await params`
- 이미지 플레이스홀더는 picsum.photos 사용
- **파일 확장자 .mdc**: 모든 가이드라인 문서는 .mdc 확장자 사용

## 최소 기술 스택 (MVP 전용)

회의실 관리 시스템에 필요한 최소한의 라이브러리만 사용:

1. **`next.js 14+`**: React 프레임워크 (App Router)
2. **`typescript`**: 타입 안전성 보장
3. **`supabase`**: 백엔드 서비스
4. **`@supabase/ssr`**: Supabase SSR 지원
5. **`tailwindcss`**: 스타일링
6. **`shadcn-ui`**: UI 컴포넌트 라이브러리
7. **`lucide-react`**: 아이콘
8. **`date-fns`**: 날짜 처리 (예약 시스템용)
9. **`react-hook-form`**: 폼 관리
10. **`zod`**: 유효성 검증 및 타입 추론

## 통일된 폴더 구조 (App Router)

```
src/
├── app/                       # Next.js App Router (필수)
│   ├── globals.css           # 글로벌 스타일
│   ├── layout.tsx            # 루트 레이아웃
│   ├── page.tsx              # 홈페이지 (예약 현황)
│   ├── my-reservations/      # 내 예약 조회
│   │   └── page.tsx
│   └── admin/                # 관리자 페이지
│       └── page.tsx
├── components/
│   ├── ui/                   # shadcn-ui 컴포넌트
│   ├── admin/                # 관리자 컴포넌트
│   ├── user/                 # 사용자 컴포넌트
│   └── common/               # 공통 컴포넌트
├── lib/
│   ├── supabase/             # Supabase 클라이언트
│   │   ├── client.ts         # 클라이언트 사이드
│   │   └── server.ts         # 서버 사이드
│   ├── services/             # 비즈니스 로직
│   │   ├── roomService.ts
│   │   └── reservationService.ts
│   ├── utils.ts              # 유틸리티 함수
│   └── validations.ts        # Zod 스키마 정의
└── types/                    # TypeScript 타입 정의
    ├── database.ts           # Supabase 데이터베이스 타입
    └── index.ts              # 공통 타입
```

## 개발 프로세스

1. **분석**: 요구사항 이해 및 TypeScript 인터페이스 정의
2. **설계**: 타입 안전한 컴포넌트 구조 설계
3. **구현**: 기능별 단계적 구현 (서버 컴포넌트 우선)
4. **테스트**: 타입 체크 및 기본적인 기능 테스트

## 핵심 원칙

1. **타입 안전성 우선**: TypeScript + Zod로 런타임/컴파일타임 오류 방지
2. **단순성**: 복잡한 패턴 대신 명확한 해결책
3. **가독성**: 타입 힌트와 명확한 변수/함수명 사용
4. **점진적 개발**: 작은 단위로 개발 (타입 체크 통과하는 단위)
5. **실용성**: 이론보다 동작하는 코드 우선

## 상태 관리

- **로컬 상태**: React useState/useReducer (타입 정의 필수)
- **서버 상태**: 직접 fetch + useEffect + TypeScript
- **폼 상태**: React Hook Form + Zod 스키마
- **복잡한 상태 관리 라이브러리는 MVP에서 제외**

## 스타일링

- **Tailwind CSS**: 유틸리티 클래스 사용
- **shadcn-ui**: 컴포넌트 베이스 라이브러리
- **반응형 디자인**: mobile-first 접근 (모든 화면 크기 지원)
- **Apple 스타일**: 모던하고 심플한 디자인

## 에러 처리

- **TypeScript 컴파일 타임**: 타입 오류 사전 방지
- **Zod 런타임 검증**: 사용자 입력 데이터 검증
- **try-catch 블록**: 비동기 작업 에러 처리
- **사용자 친화적 메시지**: 구체적이고 실행 가능한 에러 메시지
- **개발 환경**: console.error로 상세 디버깅 정보

## Next.js 14+ App Router 사용법

### 서버 컴포넌트 (기본)
```typescript
// app/page.tsx - 서버 컴포넌트 (기본)
import { roomService } from '@/lib/services/roomService';
import type { Room } from '@/types';

export default async function HomePage() {
  const rooms: Room[] = await roomService.getAllRooms();
  return <ReservationCalendar rooms={rooms} />;
}
```

### 클라이언트 컴포넌트 (필요시만)
```typescript
// components/user/ReservationForm.tsx
'use client';
import { useState } from 'react';
import type { ReservationFormData } from '@/types';

export function ReservationForm() {
  const [formData, setFormData] = useState<ReservationFormData>({
    reserver_name: '',
    reserver_phone: '',
    reserver_password: '',
    reservation_date: '',
    start_time: '',
    end_time: '',
  });
  // ...
}
```

### params 처리
```typescript
// app/admin/rooms/[id]/page.tsx
interface PageProps {
  params: Promise<{ id: string }>;
}

export default async function RoomDetailPage({ params }: PageProps) {
  const { id } = await params;
  // ...
}
```

## TypeScript 설정

### 권장 tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es2017",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### 타입 정의 예시
```typescript
// types/index.ts
export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface ReservationFormData {
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
}
```

## Zod 스키마 활용

### 유효성 검증 스키마
```typescript
// lib/validations.ts
import { z } from 'zod';

export const reservationSchema = z.object({
  reserver_name: z.string().min(1, '예약자 이름을 입력해주세요'),
  reserver_phone: z.string().regex(/^010-\d{4}-\d{4}$/, '올바른 휴대폰번호를 입력해주세요'),
  reserver_password: z.string().min(4, '비밀번호는 4자리 이상 입력해주세요'),
  reservation_date: z.string(),
  start_time: z.string(),
  end_time: z.string(),
});

export type ReservationFormData = z.infer<typeof reservationSchema>;
```

## Shadcn-ui 컴포넌트

### 설치 명령어
```bash
# 기본 컴포넌트
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add form
npx shadcn@latest add card
npx shadcn@latest add dialog
npx shadcn@latest add table
npx shadcn@latest add calendar
npx shadcn@latest add select
```

### 사용 예시
```typescript
// components/ui에 설치된 컴포넌트 사용
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
```

## Supabase 설정

### 클라이언트 설정
```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
```

### 서버 설정
```typescript
// lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database';

export const createClient = () => {
  const cookieStore = cookies();
  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // SSR에서 쿠키 설정 실패 시 무시
          }
        },
      },
    }
  );
};
```

### Migration 위치
- 새 테이블 필요시 migration 파일 생성
- 경로: `/supabase/migrations/*.sql`
- 로컬 supabase 실행하지 않음 (클라우드 사용)

## 패키지 매니저

- **npm 사용** (일관성 유지)
- package.json에 명시된 버전 사용
- 새 라이브러리 추가 시 MVP 범위 내에서만

## 개발 워크플로우

### 1. 컴포넌트 작성 순서
1. **타입 정의** (인터페이스 먼저)
2. **서버 컴포넌트 작성** (데이터 패칭)
3. **클라이언트 컴포넌트 작성** (상호작용)
4. **스타일링 적용** (Tailwind + shadcn-ui)

### 2. 서비스 함수 작성 순서
1. **타입 정의** (매개변수, 반환값)
2. **Zod 스키마** (입력 검증)
3. **비즈니스 로직** (Supabase 호출)
4. **에러 처리** (ServiceResult 반환)

### 3. 디버깅 방법
```typescript
// TypeScript 컴파일 에러 확인
npm run type-check

// 개발 서버에서 실시간 확인
npm run dev

// 빌드 타임 에러 확인
npm run build
```

## 코딩 컨벤션

### 파일명 규칙
- **컴포넌트**: PascalCase (ReservationForm.tsx)
- **서비스**: camelCase (roomService.ts)
- **타입**: PascalCase (Database.ts, index.ts)
- **유틸리티**: camelCase (utils.ts)

### 변수명 규칙
- **컴포넌트**: PascalCase
- **함수/변수**: camelCase
- **상수**: UPPER_SNAKE_CASE
- **타입/인터페이스**: PascalCase

### Import 순서
```typescript
// 1. React 관련
import React from 'react';
import { useState, useEffect } from 'react';

// 2. Next.js 관련
import { cookies } from 'next/headers';

// 3. 외부 라이브러리
import { z } from 'zod';

// 4. 내부 모듈
import { roomService } from '@/lib/services/roomService';
import type { Room } from '@/types';

// 5. 상대경로
import './globals.css';
```

## 성능 최적화 가이드

### React 최적화
```typescript
// React.memo 사용
const RoomCard = React.memo(function RoomCard({ room }: { room: Room }) {
  return <Card>{room.name}</Card>;
});

// useCallback 사용
const handleRoomSelect = useCallback((room: Room) => {
  setSelectedRoom(room);
}, []);

// useMemo 사용
const filteredRooms = useMemo(() => 
  rooms.filter(room => room.capacity >= minCapacity), 
  [rooms, minCapacity]
);
```

### Next.js 최적화
- **서버 컴포넌트 우선 사용**
- **동적 import로 코드 분할**
- **Image 컴포넌트 사용**

## 개발자 마인드셋

1. **타입 안전성 우선**: "컴파일되면 대부분 동작한다"
2. **MVP 집중**: 완벽한 추상화보다 동작하는 기능
3. **점진적 개선**: 타입 체크 통과하는 작은 단위로 개발
4. **실용성**: 이론적 완벽함보다 실제 사용자 가치
5. **일관성**: 팀 전체가 같은 패턴과 컨벤션 사용

## 문제 해결 가이드

### TypeScript 에러
1. **타입 정의 확인**: 올바른 인터페이스 사용
2. **import 경로 확인**: @/* 경로 별칭 사용
3. **null/undefined 체크**: optional chaining 사용

### Next.js App Router 에러
1. **폴더 구조 확인**: app/ 디렉토리 사용
2. **서버/클라이언트 구분**: 'use client' 적절히 사용
3. **params 처리**: Promise 형태로 처리

### Supabase 에러
1. **환경변수 확인**: .env.local 설정
2. **타입 정의 확인**: Database 인터페이스 일치
3. **RLS 설정**: 비활성화 상태 확인

당신은 **TypeScript 기반 회의실 관리 시스템** 개발에 집중하는 실용적인 개발자입니다. 
타입 안전성을 보장하면서도 복잡한 패턴보다는 단순하고 명확한 코드로 요구사항을 만족시키세요.
</file>

<file path=".cursor/rules/stepbystep.mdc">
---
description: Simplified Development Process for Meeting Room System
globs: 
alwaysApply: true
---

## 회의실 관리 시스템 개발 프로세스

회의실 예약 프로그램에 특화된 단순화된 개발 프로세스입니다.

## 핵심 원칙
- **MVP 우선**: 동작하는 기본 기능부터
- **단순함**: 복잡한 분석보다는 빠른 구현
- **점진적 개발**: 작은 단위로 기능 완성

---

## 단순화된 2단계 프로세스

### 1단계: 빠른 분석 (5분 이내)
**필수 확인 사항:**
- 기존 파일 구조 파악
- 관련 컴포넌트나 서비스 확인
- Supabase 테이블 스키마 확인

**출력 형식:**
```
### 현재 상황
- 관련 파일: [파일명들]
- 필요한 기능: [간단한 설명]
- 예상 작업: [1-3개 핵심 작업]
```

### 2단계: 구현 및 검증
**실행 방식:**
1. 가장 간단한 버전부터 구현
2. 기본 동작 확인
3. 필요시 점진적 개선

**검증 항목:**
- [ ] 기본 기능 동작
- [ ] 사용자 입력 처리
- [ ] 에러 상황 처리
- [ ] 기존 코드와의 호환성

---

## 회의실 시스템 특화 체크리스트

### 사용자 기능
- [ ] 예약 현황 조회 가능
- [ ] 예약 생성 가능
- [ ] 내 예약 조회 가능
- [ ] 예약 취소 가능

### 관리자 기능
- [ ] 회의실 등록 가능
- [ ] 회의실 수정 가능
- [ ] 회의실 삭제 가능

### 기술적 요구사항
- [ ] Supabase 연동 정상
- [ ] 실시간 업데이트 동작
- [ ] 모바일 반응형 지원
- [ ] 기본적인 에러 처리

---

## 개발 순서 가이드

### 1주차: 기본 CRUD
1. Supabase 설정 및 테이블 생성
2. 관리자 회의실 관리 페이지
3. 기본적인 회의실 등록/조회

### 2주차: 예약 시스템
1. 예약 현황 표시 컴포넌트
2. 예약 생성 기능
3. 내 예약 조회 기능

### 3주차: 완성도 높이기
1. 실시간 동기화
2. UI/UX 개선
3. 에러 처리 강화

---

## 응답 구조

모든 개발 요청에 대해 다음 형식으로 응답:

```markdown
## 현재 상황 분석
[관련 파일 및 필요 작업 간단 정리]

## 구현 계획
[구체적인 구현 방법]

## 코드 구현
[실제 코드와 설명]

## 동작 확인
[테스트 방법 및 예상 결과]
```

---

## 주의사항

- 완벽한 분석보다는 빠른 프로토타입 제작
- 복잡한 아키텍처 패턴 대신 직관적인 구조
- 기능 구현 후 점진적 개선
- 사용자 요구사항 우선, 기술적 완벽함은 차순위

당신은 회의실 관리 시스템을 빠르고 효율적으로 개발하는 실용적인 개발자입니다.
</file>

<file path=".cursor/rules/supabase.mdc">
---
description: Supabase Guidelines for Meeting Room System
globs: supabase/migrations/*.sql
---

# 회의실 관리 시스템 Supabase 가이드라인

## 회의실 시스템 Migration 규칙

### 파일 네이밍 규칙
```
supabase/migrations/
├── 20241215000001_create_meeting_rooms.sql
├── 20241215000002_create_reservations.sql  
├── 20241215000003_add_sample_data.sql
```

### Migration 작성 규칙

#### 1. 테이블 생성 패턴
```sql
-- 항상 IF NOT EXISTS 사용
CREATE TABLE IF NOT EXISTS meeting_rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    location VARCHAR(200) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- RLS 비활성화 (요구사항)
ALTER TABLE meeting_rooms DISABLE ROW LEVEL SECURITY;
```

#### 2. 제약조건 추가 패턴
```sql
-- GIST 확장 활성화
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- 시간 중복 방지 제약조건
ALTER TABLE reservations 
ADD CONSTRAINT IF NOT EXISTS no_overlapping_reservations 
EXCLUDE USING GIST (
    room_id WITH =,
    reservation_date WITH =,
    tsrange(start_time::text, end_time::text) WITH &&
) WHERE (status = 'active');
```

#### 3. 인덱스 생성 패턴
```sql
-- 성능 최적화 인덱스
CREATE INDEX IF NOT EXISTS idx_reservations_phone 
ON reservations(reserver_phone);

CREATE INDEX IF NOT EXISTS idx_reservations_date_room 
ON reservations(reservation_date, room_id, status);

CREATE INDEX IF NOT EXISTS idx_meeting_rooms_name 
ON meeting_rooms(name);
```

### 회의실 시스템 필수 컬럼

#### meeting_rooms 테이블
```sql
-- 필수 컬럼
id UUID PRIMARY KEY                    -- 고유 식별자
name VARCHAR(100) NOT NULL UNIQUE      -- 회의실 이름 (중복 불가)
location VARCHAR(200) NOT NULL         -- 위치
capacity INTEGER NOT NULL              -- 수용 인원
created_at TIMESTAMP WITH TIME ZONE   -- 생성 시간
updated_at TIMESTAMP WITH TIME ZONE   -- 수정 시간
```

#### reservations 테이블  
```sql
-- 필수 컬럼
id UUID PRIMARY KEY                    -- 예약 고유 식별자
room_id UUID REFERENCES meeting_rooms(id) -- 회의실 참조
reservation_date DATE NOT NULL         -- 예약 날짜
start_time TIME NOT NULL              -- 시작 시간
end_time TIME NOT NULL                -- 종료 시간
reserver_name VARCHAR(50) NOT NULL    -- 예약자 이름
reserver_phone VARCHAR(20) NOT NULL   -- 예약자 휴대폰번호
reserver_password VARCHAR(100) NOT NULL -- 예약 비밀번호
status VARCHAR(20) DEFAULT 'active'   -- 예약 상태
created_at TIMESTAMP WITH TIME ZONE  -- 예약 생성 시간
updated_at TIMESTAMP WITH TIME ZONE  -- 예약 수정 시간
```

### 트리거 함수 (updated_at 자동화)
```sql
-- updated_at 자동 업데이트 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 트리거 적용
CREATE TRIGGER update_meeting_rooms_updated_at 
    BEFORE UPDATE ON meeting_rooms 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_reservations_updated_at 
    BEFORE UPDATE ON reservations 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
```

### 샘플 데이터 (개발/테스트용)
```sql
-- 회의실 샘플 데이터
INSERT INTO meeting_rooms (name, location, capacity) VALUES 
('휴게실 A', '1층 동쪽', 4),
('휴게실 B', '1층 서쪽', 6),
('휴게실 C', '2층 중앙', 8),
('휴게실 D', '2층 북쪽', 4),
('휴게실 E', '3층 남쪽', 10)
ON CONFLICT (name) DO NOTHING;

-- 예약 샘플 데이터  
INSERT INTO reservations (room_id, reservation_date, start_time, end_time, reserver_name, reserver_phone, reserver_password) 
SELECT 
    (SELECT id FROM meeting_rooms WHERE name = '휴게실 A'),
    CURRENT_DATE,
    '09:00',
    '10:00',
    '김철수',
    '010-1234-5678',
    'password123'
WHERE NOT EXISTS (
    SELECT 1 FROM reservations 
    WHERE room_id = (SELECT id FROM meeting_rooms WHERE name = '휴게실 A')
    AND reservation_date = CURRENT_DATE 
    AND start_time = '09:00'
);
```

### Migration 검증 쿼리
```sql
-- 테이블 생성 확인
SELECT tablename FROM pg_tables WHERE schemaname = 'public';

-- 제약조건 확인
SELECT conname, contype FROM pg_constraint WHERE conrelid = 'reservations'::regclass;

-- 인덱스 확인  
SELECT indexname FROM pg_indexes WHERE tablename IN ('meeting_rooms', 'reservations');

-- 샘플 데이터 확인
SELECT COUNT(*) FROM meeting_rooms;
SELECT COUNT(*) FROM reservations;
```

### 회의실 시스템 특화 쿼리 패턴

#### 예약 현황 조회
```sql
-- 특정 날짜의 전체 예약 현황
SELECT 
    mr.id,
    mr.name,
    mr.location,
    mr.capacity,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', r.id,
                'start_time', r.start_time,
                'end_time', r.end_time,
                'reserver_name', r.reserver_name,
                'status', r.status
            ) ORDER BY r.start_time
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'::json
    ) as reservations
FROM meeting_rooms mr
LEFT JOIN reservations r ON mr.id = r.room_id 
    AND r.reservation_date = CURRENT_DATE
    AND r.status = 'active'
GROUP BY mr.id, mr.name, mr.location, mr.capacity
ORDER BY mr.name;
```

#### 시간 중복 확인
```sql
-- 새 예약 시간 중복 확인
SELECT COUNT(*) FROM reservations 
WHERE room_id = $1 
AND reservation_date = $2 
AND status = 'active'
AND tsrange($3::text, $4::text) && tsrange(start_time::text, end_time::text);
```

### 에러 처리 및 복구

#### 일반적인 에러 상황
```sql
-- 중복 예약 시도 시 제약조건 위반
-- 23P01: exclusion_violation (GIST 제약조건)

-- 외래키 제약조건 위반  
-- 23503: foreign_key_violation

-- 유니크 제약조건 위반
-- 23505: unique_violation
```

### 성능 모니터링 쿼리
```sql
-- 자주 사용되는 쿼리 성능 확인
EXPLAIN ANALYZE 
SELECT * FROM reservations 
WHERE reserver_phone = '010-1234-5678' 
AND reserver_password = 'password123';

-- 인덱스 사용량 확인
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename IN ('meeting_rooms', 'reservations');
```

### 백업 및 복구 전략
```sql
-- 중요 데이터 백업 (예약 데이터)
COPY reservations TO '/backup/reservations_backup.csv' WITH CSV HEADER;

-- 회의실 설정 백업
COPY meeting_rooms TO '/backup/meeting_rooms_backup.csv' WITH CSV HEADER;
```

### Migration 체크리스트

새 Migration 작성 시 확인사항:
- [ ] `IF NOT EXISTS` 구문 사용
- [ ] RLS 비활성화 설정
- [ ] 적절한 인덱스 생성  
- [ ] 외래키 제약조건 설정 (CASCADE 고려)
- [ ] 샘플 데이터 포함 (중복 방지)
- [ ] 트리거 함수 적용
- [ ] 검증 쿼리 포함

### 주의사항

1. **RLS는 비활성화** (프로젝트 요구사항)
2. **한 번에 하나의 Migration 파일만 생성**
3. **샘플 데이터는 개발환경에서만 사용**
4. **프로덕션에서는 샘플 데이터 제외**
5. **Migration은 항상 idempotent하게 작성**
</file>

<file path=".cursor/rules/TDD.mdc">
---
description: Simplified TDD for Meeting Room System MVP
globs: 
alwaysApply: true
---

# 회의실 관리 시스템 테스트 전략

## 📌 MVP에 적합한 실용적 테스트 접근법

**초보 개발자를 위한 점진적 테스트 전략 - TDD 완전 적용 대신 실용적 접근**

## 테스트 우선순위 (중요도 순)

### 1. 수동 테스트 (필수 - 100%)
```
✅ 브라우저에서 직접 기능 확인
✅ 다양한 시나리오 클릭 테스트
✅ 에러 상황 재현 테스트
```

### 2. 핵심 로직 단위 테스트 (권장 - 30%)
```
✅ 예약 시간 중복 검증 함수
✅ 날짜/시간 유효성 검증 함수
✅ 폼 데이터 검증 함수
```

### 3. 통합 테스트 (선택적 - 10%)
```
⚪ Supabase 연동 테스트 (나중에)
⚪ API 호출 테스트 (나중에)
```

## 실용적 개발 흐름

### Phase 1: 기능 구현 우선
1. **기능 구현** → 브라우저 테스트
2. **수정** → 재테스트  
3. **동작 확인** → 다음 기능

### Phase 2: 안정화 (기능 완료 후)
1. **핵심 로직** → 단위 테스트 추가
2. **버그 발견** → 테스트 케이스 추가
3. **리팩토링** → 테스트로 안전성 확보

## 회의실 시스템 테스트 체크리스트

### 사용자 기능 수동 테스트
```
예약 현황 조회:
□ 모든 회의실이 표시되는가?
□ 예약된 시간이 정확히 표시되는가?
□ 실시간 업데이트가 되는가?

예약 생성:
□ 필수 필드 입력 시 예약 가능한가?
□ 중복 시간 예약 시 에러 메시지가 나오는가?
□ 성공 시 현황이 즉시 업데이트되는가?

내 예약 조회:
□ 올바른 휴대폰번호/비밀번호로 조회되는가?
□ 잘못된 정보 입력 시 적절한 에러 메시지가 나오는가?
□ 예약 취소가 정상 동작하는가?
```

### 관리자 기능 수동 테스트
```
회의실 관리:
□ 새 회의실 등록이 가능한가?
□ 중복 이름 입력 시 에러가 나오는가?
□ 회의실 수정이 정상 동작하는가?
□ 예약이 있는 회의실 삭제 시 경고가 나오는가?
```

## 단위 테스트 대상 (핵심만)

### 1. 시간 검증 함수
```javascript
// lib/utils/timeValidation.js
export function isTimeConflict(existingReservations, newReservation) {
  // 테스트할 핵심 로직
}

// __tests__/timeValidation.test.js
describe('시간 중복 검증', () => {
  test('기존 예약과 겹치는 시간 감지', () => {
    // 간단한 테스트 케이스
  });
});
```

### 2. 폼 검증 함수
```javascript
// lib/utils/validation.js
export function validateReservationForm(data) {
  // 테스트할 유효성 검증 로직
}

// __tests__/validation.test.js  
describe('예약 폼 검증', () => {
  test('필수 필드 누락 시 에러 반환', () => {
    // 기본적인 검증 테스트
  });
});
```

## 테스트 작성 시점

### 초기 개발 (1-2주차)
- **테스트 없이 기능 구현 집중**
- 브라우저 수동 테스트만 수행
- 기본 기능 동작 확인

### 중기 개발 (3주차)
- **핵심 함수에 단위 테스트 추가**
- 버그 발견 시 테스트 케이스 추가
- 리팩토링 전 안전망 구성

### 완성 후
- 추가 기능 개발 시 TDD 적용 고려
- 복잡한 로직에 대한 테스트 보강

## 테스트 도구 설정 (필요시)

```bash
# 기본 테스트 환경 (선택적)
npm install --save-dev jest @testing-library/react @testing-library/jest-dom
```

## 에러 상황 테스트 우선순위

### High Priority (반드시 테스트)
- 잘못된 사용자 입력
- 네트워크 연결 끊김
- 중복 예약 시도

### Medium Priority (가능하면 테스트)  
- 동시 접속 상황
- 큰 데이터량 처리

### Low Priority (나중에)
- 성능 테스트
- 보안 테스트

## 실용적 조언

1. **완벽한 테스트보다 동작하는 기능**
2. **복잡한 테스트 프레임워크보다 간단한 확인**
3. **사용자 관점에서 테스트**
4. **버그 발견 즉시 재현 방법 문서화**

MVP 단계에서는 테스트 커버리지보다 **기능 완성도**에 집중하고, 
안정화 단계에서 점진적으로 테스트를 보강하는 것이 현실적입니다.
</file>

<file path="doc/datebase.mdc">
---
description: Database Design for Meeting Room System
globs:
alwaysApply: true
---

# 회의실 관리 시스템 데이터베이스 설계

## 개요
Next.js 14+ (App Router) + Supabase(PostgreSQL) + Vercel 스택을 사용한 회의실 관리 시스템의 데이터베이스 설계 문서입니다. TypeScript와 함께 최소 스펙의 MVP 구현을 위한 데이터플로우와 스키마를 정의합니다.

## 데이터플로우

### 1. 회의실 데이터 흐름

#### 1.1 회의실 등록 (관리자)
```
관리자 입력 → TypeScript 타입 검증 → Zod 유효성 검증 → 중복 확인 → meeting_rooms 테이블 INSERT
```

#### 1.2 회의실 조회 (전체)
```
사용자/관리자 요청 → Supabase Client → meeting_rooms 테이블 SELECT → TypeScript 타입 반환
```

#### 1.3 회의실 수정 (관리자)
```
관리자 입력 → 권한 확인 → 기존 예약 확인 → meeting_rooms 테이블 UPDATE → Realtime 업데이트
```

#### 1.4 회의실 삭제 (관리자)
```
관리자 요청 → 권한 확인 → reservations 테이블 확인 → 경고/확인 → meeting_rooms 테이블 CASCADE DELETE
```

### 2. 예약 데이터 흐름

#### 2.1 예약 현황 조회
```
사용자 요청 → meeting_rooms + reservations 테이블 JOIN → RoomWithReservations 타입 반환
```

#### 2.2 예약 생성
```
사용자 입력 → Zod 스키마 검증 → 시간 중복 확인 → reservations 테이블 INSERT → Realtime 현황 업데이트
```

#### 2.3 내 예약 조회
```
휴대폰번호+비밀번호 입력 → 형식 검증 → reservations 테이블 WHERE 조건 필터링 → Reservation[] 반환
```

#### 2.4 예약 취소
```
예약 ID + 인증 → 취소 가능 시간 확인 → reservations 테이블 status UPDATE → Realtime 동기화
```

### 3. 실시간 동기화 흐름
```
데이터 변경 이벤트 → Supabase Realtime → TypeScript 타입 체크 → 클라이언트 실시간 업데이트
```

## 데이터베이스 스키마

### 테이블 구조

#### 1. meeting_rooms (회의실 정보)
```sql
CREATE TABLE IF NOT EXISTS meeting_rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    location VARCHAR(200) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**TypeScript 인터페이스:**
```typescript
interface MeetingRoom {
  id: string;
  name: string;
  location: string;
  capacity: number;
  created_at: string;
  updated_at: string;
}
```

**필드 설명:**
- `id`: 회의실 고유 식별자 (UUID)
- `name`: 회의실 이름 (중복 불가, UNIQUE 제약)
- `location`: 회의실 위치
- `capacity`: 수용 가능 인원수 (양수, CHECK 제약)
- `created_at`: 생성 일시 (자동 생성)
- `updated_at`: 수정 일시 (트리거로 자동 업데이트)

#### 2. reservations (예약 정보)
```sql
CREATE TABLE IF NOT EXISTS reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE,
    reservation_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    reserver_phone VARCHAR(20) NOT NULL,
    reserver_password VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**TypeScript 인터페이스:**
```typescript
interface Reservation {
  id: string;
  room_id: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
  status: 'active' | 'cancelled';
  created_at: string;
  updated_at: string;
}
```

**필드 설명:**
- `id`: 예약 고유 식별자 (UUID)
- `room_id`: 회의실 참조 (외래키, CASCADE 삭제)
- `reservation_date`: 예약 날짜 (DATE 타입)
- `start_time`: 시작 시간 (TIME 타입)
- `end_time`: 종료 시간 (TIME 타입)
- `reserver_name`: 예약자 이름
- `reserver_phone`: 예약자 휴대폰번호 (조회 키)
- `reserver_password`: 예약 비밀번호 (조회 인증)
- `status`: 예약 상태 (active, cancelled)
- `created_at`: 예약 생성 일시
- `updated_at`: 예약 수정 일시

### 제약 조건

#### 1. 시간 중복 방지 (GIST 제약조건)
```sql
-- GIST 확장 활성화
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- 동일 회의실, 동일 날짜의 시간 중복 방지
ALTER TABLE reservations
ADD CONSTRAINT no_overlapping_reservations
EXCLUDE USING GIST (
    room_id WITH =,
    reservation_date WITH =,
    tsrange(start_time::text, end_time::text) WITH &&
) WHERE (status = 'active');
```

**설명:**
- PostgreSQL의 GIST 인덱스를 활용한 시간 범위 겹침 방지
- 동일 회의실, 동일 날짜에서 활성 예약 시간 겹침 방지
- 취소된 예약(`status = 'cancelled'`)은 제약에서 제외
- 동시성 제어를 데이터베이스 레벨에서 보장

#### 2. 참조 무결성
```sql
room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE
```
**설명:** 
- 회의실 삭제 시 관련 예약도 함께 삭제 (CASCADE DELETE)
- 데이터 일관성 보장

#### 3. 데이터 유효성 제약
```sql
-- 수용 인원 양수 제약
capacity INTEGER NOT NULL CHECK (capacity > 0)

-- 예약 상태 제약
status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled'))
```

### 성능 최적화 인덱스

#### 1. 예약 조회 최적화
```sql
-- 휴대폰번호 기반 예약 조회 (내 예약 조회)
CREATE INDEX IF NOT EXISTS idx_reservations_phone ON reservations(reserver_phone);

-- 날짜별 예약 현황 조회 (전체 현황 조회)
CREATE INDEX IF NOT EXISTS idx_reservations_date_room ON reservations(reservation_date, room_id, status);
```

#### 2. 회의실 조회 최적화
```sql
-- 회의실명 검색
CREATE INDEX IF NOT EXISTS idx_meeting_rooms_name ON meeting_rooms(name);
```

### 주요 쿼리 패턴

#### 1. 전체 예약 현황 조회 (TypeScript)
```typescript
// Supabase 클라이언트 쿼리
async function getReservationsByDate(date: string): Promise<RoomWithReservations[]> {
  const { data, error } = await supabase
    .from('meeting_rooms')
    .select(`
      *,
      reservations!inner(
        id,
        reservation_date,
        start_time,
        end_time,
        reserver_name,
        status
      )
    `)
    .eq('reservations.reservation_date', date)
    .eq('reservations.status', 'active')
    .order('name');
  
  if (error) throw error;
  return data as RoomWithReservations[];
}
```

**해당 SQL:**
```sql
SELECT 
    mr.id, 
    mr.name, 
    mr.location, 
    mr.capacity,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', r.id,
                'start_time', r.start_time,
                'end_time', r.end_time,
                'reserver_name', r.reserver_name,
                'status', r.status
            ) ORDER BY r.start_time
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'::json
    ) as reservations
FROM meeting_rooms mr
LEFT JOIN reservations r ON mr.id = r.room_id 
    AND r.reservation_date = $1
    AND r.status = 'active'
GROUP BY mr.id, mr.name, mr.location, mr.capacity
ORDER BY mr.name;
```

#### 2. 내 예약 조회 (TypeScript)
```typescript
async function getMyReservations(phone: string, password: string): Promise<Reservation[]> {
  const { data, error } = await supabase
    .from('reservations')
    .select(`
      *,
      meeting_rooms(name, location)
    `)
    .eq('reserver_phone', phone)
    .eq('reserver_password', password)
    .order('reservation_date', { ascending: false });
  
  if (error) throw error;
  return data;
}
```

**해당 SQL:**
```sql
SELECT 
    r.id, 
    mr.name, 
    mr.location, 
    r.reservation_date, 
    r.start_time, 
    r.end_time, 
    r.status
FROM reservations r
JOIN meeting_rooms mr ON r.room_id = mr.id
WHERE r.reserver_phone = $1 AND r.reserver_password = $2
ORDER BY r.reservation_date DESC, r.start_time DESC;
```

#### 3. 예약 시간 중복 확인 (PostgreSQL 함수)
```sql
-- 시간 중복 확인 함수
CREATE OR REPLACE FUNCTION check_time_conflict(
    p_room_id UUID,
    p_date DATE,
    p_start_time TIME,
    p_end_time TIME
)
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(*)::INTEGER
        FROM reservations 
        WHERE room_id = p_room_id 
        AND reservation_date = p_date 
        AND status = 'active'
        AND tsrange(p_start_time::text, p_end_time::text) && tsrange(start_time::text, end_time::text)
    );
END;
$$ LANGUAGE plpgsql;
```

**TypeScript 호출:**
```typescript
async function checkTimeConflict(
  roomId: string, 
  date: string, 
  startTime: string, 
  endTime: string
): Promise<boolean> {
  const { data, error } = await supabase
    .rpc('check_time_conflict', {
      p_room_id: roomId,
      p_date: date,
      p_start_time: startTime,
      p_end_time: endTime
    });
  
  if (error) throw error;
  return data > 0;
}
```

## 데이터 무결성 보장

### 1. 동시성 제어
- **PostgreSQL의 GIST 인덱스**: 시간 범위 겹침 방지
- **트랜잭션 레벨**: 예약 중복 방지
- **TypeScript 타입 체크**: 컴파일 타임 오류 방지

### 2. 데이터 일관성
- **외래키 제약**: 참조 무결성 보장 (CASCADE DELETE)
- **CHECK 제약**: 유효한 데이터 값 보장 (양수, 상태값)
- **Zod 스키마**: 런타임 데이터 검증

### 3. 실시간 동기화
```typescript
// Supabase Realtime 구독
const subscription = supabase
  .channel('reservations')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'reservations'
  }, (payload: RealtimePostgresChangesPayload<Reservation>) => {
    // TypeScript 타입 안전성 보장
    switch(payload.eventType) {
      case 'INSERT':
        setReservations(prev => [...prev, payload.new]);
        break;
      case 'UPDATE':
        setReservations(prev => 
          prev.map(r => r.id === payload.new.id ? payload.new : r)
        );
        break;
      case 'DELETE':
        setReservations(prev => 
          prev.filter(r => r.id !== payload.old.id)
        );
        break;
    }
  })
  .subscribe();
```

## 자동화 트리거

### updated_at 자동 업데이트
```sql
-- updated_at 자동 업데이트 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- meeting_rooms 테이블에 트리거 적용
CREATE TRIGGER update_meeting_rooms_updated_at
    BEFORE UPDATE ON meeting_rooms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- reservations 테이블에 트리거 적용
CREATE TRIGGER update_reservations_updated_at
    BEFORE UPDATE ON reservations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## TypeScript 데이터베이스 타입

### Supabase 생성 타입 정의
```typescript
// types/database.ts
export interface Database {
  public: {
    Tables: {
      meeting_rooms: {
        Row: MeetingRoom;
        Insert: Omit<MeetingRoom, 'id' | 'created_at' | 'updated_at'> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: Partial<Omit<MeetingRoom, 'id' | 'created_at' | 'updated_at'>>;
      };
      reservations: {
        Row: Reservation;
        Insert: Omit<Reservation, 'id' | 'created_at' | 'updated_at'> & {
          id?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: Partial<Omit<Reservation, 'id' | 'created_at' | 'updated_at'>>;
      };
    };
  };
}

// 확장 타입 정의
export interface RoomWithReservations extends MeetingRoom {
  reservations: Reservation[];
}

export interface CreateRoomData {
  name: string;
  location: string;
  capacity: number;
}

export interface CreateReservationData {
  room_id: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
}
```

## 더미 데이터 구조

### 회의실 더미 데이터 (5개)
```sql
INSERT INTO meeting_rooms (name, location, capacity) VALUES
('휴게실 A', '1층 동쪽', 4),
('휴게실 B', '1층 서쪽', 6),
('휴게실 C', '2층 중앙', 8),
('휴게실 D', '2층 북쪽', 4),
('휴게실 E', '3층 남쪽', 10)
ON CONFLICT (name) DO NOTHING;
```

### 예약 더미 데이터 패턴
```sql
-- 현재 날짜부터 일주일간의 예약 데이터
-- 다양한 시간대와 휴대폰번호/비밀번호 조합
-- 일부 취소된 예약 포함 (status = 'cancelled')
INSERT INTO reservations (room_id, reservation_date, start_time, end_time, reserver_name, reserver_phone, reserver_password, status)
SELECT
    (SELECT id FROM meeting_rooms WHERE name = '휴게실 A'),
    CURRENT_DATE,
    '09:00',
    '10:00',
    '김철수',
    '010-1234-5678',
    'password123',
    'active'
UNION ALL
-- ... 추가 더미 데이터
SELECT
    (SELECT id FROM meeting_rooms WHERE name = '휴게실 B'),
    CURRENT_DATE - 1,
    '13:00',
    '14:00',
    '이취소',
    '010-9999-9999',
    'cancelled123',
    'cancelled';
```

## 확장성 고려사항

### 1. 파티셔닝 (필요시)
```sql
-- 예약 테이블을 날짜별로 파티셔닝 (대용량 데이터 시)
CREATE TABLE reservations_2024 PARTITION OF reservations
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

### 2. 아카이브 전략 (필요시)
```sql
-- 과거 예약 데이터의 별도 테이블 보관
CREATE TABLE reservations_archive AS 
SELECT * FROM reservations 
WHERE reservation_date < CURRENT_DATE - INTERVAL '1 year';
```

### 3. 캐싱 전략 (TypeScript)
```typescript
// React Query를 활용한 캐싱 (선택적)
const { data: rooms } = useQuery({
  queryKey: ['rooms'],
  queryFn: () => roomService.getAllRooms(),
  staleTime: 5 * 60 * 1000, // 5분간 캐시
});

// 메모리 캐싱 (간단한 방법)
const roomsCache = new Map<string, MeetingRoom>();
```

## RLS 정책 (비활성화)

요구사항에 따라 Row Level Security는 비활성화하여 단순한 구조로 유지합니다.

```sql
ALTER TABLE meeting_rooms DISABLE ROW LEVEL SECURITY;
ALTER TABLE reservations DISABLE ROW LEVEL SECURITY;
```

## Migration 파일 구조

### 단일 Migration 파일
```sql
-- /supabase/migrations/20241215000001_init_meeting_room_system.sql
-- 1. 확장 활성화 (btree_gist)
-- 2. 테이블 생성 (meeting_rooms, reservations)
-- 3. 제약조건 추가 (GIST, 외래키, CHECK)
-- 4. 인덱스 생성 (성능 최적화)
-- 5. RLS 비활성화
-- 6. 트리거 함수 생성 (updated_at 자동화)
-- 7. PostgreSQL 함수 생성 (중복 확인)
-- 8. 더미 데이터 삽입 (개발/테스트용)
```

## 데이터베이스 검증 및 테스트

### TypeScript 타입 체크
```typescript
// 컴파일 타임 타입 검증
const reservation: CreateReservationData = {
  room_id: "uuid-string",
  reservation_date: "2024-12-15",
  start_time: "14:00",
  end_time: "15:30",
  reserver_name: "홍길동",
  reserver_phone: "010-1234-5678",
  reserver_password: "secure123"
};

// Zod 런타임 검증
const validatedData = reservationSchema.parse(reservation);
```

### 데이터베이스 제약조건 테스트
```sql
-- 시간 중복 테스트 (실패해야 함)
INSERT INTO reservations (room_id, reservation_date, start_time, end_time, reserver_name, reserver_phone, reserver_password)
VALUES 
    ('same-room-id', '2024-12-15', '14:00', '15:00', '사용자1', '010-1111-1111', 'pass1'),
    ('same-room-id', '2024-12-15', '14:30', '15:30', '사용자2', '010-2222-2222', 'pass2');
-- 에러: exclusion constraint "no_overlapping_reservations" violated
```

이 데이터베이스 설계는 TypeScript와 Next.js App Router를 기반으로 한 안정적이고 확장 가능한 회의실 관리 시스템 구현을 위한 완전한 데이터 계층을 제공합니다.
</file>

<file path="README.md">
# 회의실 관리 시스템

Next.js 15 + TypeScript + Supabase 기반 회의실 예약 시스템

## 🚀 시작하기
```bash
npm run dev
# http://localhost:3000
```

## 📁 구조
```
src/
├── app/                    # Next.js App Router
│   ├── page.tsx           # 홈페이지 (예약 현황)
│   ├── layout.tsx         # 루트 레이아웃
│   └── providers.tsx      # React Query Provider
├── components/ui/          # shadcn-ui 컴포넌트
├── lib/supabase/          # Supabase 클라이언트
│   ├── client.ts          # 클라이언트 사이드
│   └── server.ts          # 서버 사이드
└── hooks/use-toast.ts     # Toast 훅
```

## 🗄️ 스키마

### meeting_rooms
- id (UUID, PK)
- name (VARCHAR(100), UNIQUE) - 회의실명
- location (VARCHAR(200)) - 위치  
- capacity (INTEGER) - 수용인원
- created_at, updated_at (TIMESTAMP)

### reservations
- id (UUID, PK)
- room_id (UUID, FK) - 회의실 ID
- reservation_date (DATE) - 예약일
- start_time, end_time (TIME) - 시작/종료 시간
- reserver_name (VARCHAR(50)) - 예약자명
- reserver_phone (VARCHAR(20)) - 예약자 전화번호
- reserver_password (VARCHAR(100)) - 예약 비밀번호
- password_hash (TEXT) - 해싱된 비밀번호
- status (VARCHAR(20)) - 'active' | 'cancelled'
- created_at, updated_at (TIMESTAMP)

## 🔧 핵심 기능

### 데이터베이스 제약조건
- **시간 중복 방지**: GIST 제약조건으로 동일 회의실, 동일 날짜의 시간 겹침 방지
- **시간 유효성**: 종료 시간 > 시작 시간 검증
- **비밀번호 보안**: bcrypt 해싱으로 비밀번호 암호화

### Supabase 설정
- **RLS 활성화**: Row Level Security로 데이터 접근 제어
- **정책**: 회의실(읽기), 예약(읽기/생성), 서비스 역할만 수정/삭제
- **인덱스**: 성능 최적화를 위한 복합 인덱스

## 🛠️ 기술 스택
- **Frontend**: Next.js 15, React 19, TypeScript
- **Styling**: Tailwind CSS, shadcn-ui
- **Backend**: Supabase (PostgreSQL)
- **Form**: React Hook Form, Zod
- **State**: React Query, Zustand
- **Icons**: Lucide React
- **Utils**: date-fns, es-toolkit, ts-pattern

## 📝 개발 가이드라인

### 핵심 원칙
- **타입 안전성 우선**: TypeScript + Zod로 런타임/컴파일타임 오류 방지
- **서버 컴포넌트 우선**: Next.js App Router의 서버 컴포넌트 기본 사용
- **단순함**: 복잡한 패턴보다 명확한 해결책
- **실용성**: 이론보다 동작하는 코드 우선

### 파일 구조 규칙
- **컴포넌트**: PascalCase (ReservationForm.tsx)
- **서비스**: camelCase (roomService.ts)
- **타입**: PascalCase (Database.ts)
- **유틸리티**: camelCase (utils.ts)

### Supabase 클라이언트 사용법
```typescript
// 클라이언트 사이드
import { createClient } from '@/lib/supabase/client';
const supabase = createClient();

// 서버 사이드
import { createClient } from '@/lib/supabase/server';
const supabase = await createClient();
```

## 🔒 보안 고려사항
- **비밀번호 해싱**: bcrypt로 예약 비밀번호 암호화
- **입력 검증**: Zod 스키마로 모든 사용자 입력 검증
- **RLS 정책**: Supabase Row Level Security로 데이터 접근 제어
- **HTTPS**: Vercel 기본 제공 HTTPS 사용

## 📋 TODO
- [ ] 예약 현황 조회 페이지 구현
- [ ] 예약 생성 폼 구현
- [ ] 내 예약 조회 기능 구현
- [ ] 관리자 회의실 관리 페이지 구현
- [ ] 실시간 업데이트 기능 구현
- [ ] 모바일 반응형 최적화

## 🚨 중요 사항
- **RLS 비활성화**: 현재 모든 데이터 접근 가능
- **비밀번호 보안**: 예약 비밀번호는 bcrypt로 해싱되어 저장
- **시간 중복 방지**: GIST 제약조건으로 데이터베이스 레벨에서 중복 예약 방지
- **타입 안전성**: 모든 데이터베이스 작업은 TypeScript 타입으로 보호됨
</file>

<file path="src/app/page.tsx">
'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { useToast } from '@/hooks/use-toast';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card } from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from '@/components/ui/sheet';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { generateTimeSlots, isOverlapping } from '@/lib/utils';
import type { RoomWithReservations } from '@/types';
import { getRoomsWithReservationsByDate } from '@/lib/services/rooms';
import { createReservation } from '@/lib/services/reservations';
import { createClient } from '@/lib/supabase/client';
import { z } from 'zod';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

export default function Home() {
  const { toast } = useToast();
  const [date, setDate] = useState<string>(() => new Date().toISOString().slice(0, 10));
  const [rooms, setRooms] = useState<RoomWithReservations[]>([]);
  const [loading, setLoading] = useState(false);
  const [open, setOpen] = useState(false);
  const [selectedRoomId, setSelectedRoomId] = useState<string | null>(null);

  const timeSlots = useMemo(() => generateTimeSlots(9, 18, 30), []);

  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      setLoading(true);
      try {
        const data = await getRoomsWithReservationsByDate(date);
        if (!cancelled) setRooms(data);
      } catch (e: any) {
        toast({ title: '불러오기 실패', description: e?.message ?? '데이터 조회 중 오류', variant: 'destructive' });
      } finally {
        if (!cancelled) setLoading(false);
      }
    };
    run();
    return () => { cancelled = true; };
  }, [date, toast]);

  // Realtime subscription to refresh when reservations change
  useEffect(() => {
    const supabase = createClient();
    const channel = supabase
      .channel('reservations:realtime')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'reservations' }, async (payload) => {
        // Refresh if the change touches the selected date
        const d = (payload.new as any)?.reservation_date || (payload.old as any)?.reservation_date;
        if (!d || d === date) {
          const data = await getRoomsWithReservationsByDate(date);
          setRooms(data);
        }
      })
      .subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [date]);

  return (
    <div className="max-w-5xl mx-auto p-6 space-y-6">
      <header className="flex flex-col sm:flex-row items-start sm:items-end justify-between gap-4">
        <div>
          <h1 className="text-2xl font-semibold">회의실 예약</h1>
          <p className="text-sm text-muted-foreground">날짜별 현황 확인 및 예약</p>
        </div>
        <div className="flex items-center gap-3">
          <div className="space-y-1">
            <Label htmlFor="date">날짜</Label>
            <Input id="date" type="date" value={date} onChange={(e) => setDate(e.target.value)} />
          </div>
          <Button onClick={() => setDate(new Date().toISOString().slice(0, 10))} variant="secondary">오늘</Button>
        </div>
      </header>

      <Separator />

      {loading ? (
        <p className="text-sm text-muted-foreground">불러오는 중...</p>
      ) : (
        <div className="grid md:grid-cols-2 gap-4">
          {rooms.map((room) => (
            <Card key={room.id} className="p-4 space-y-3">
              <div className="flex items-center justify-between">
                <div>
                  <p className="font-semibold">{room.name}</p>
                  <p className="text-xs text-muted-foreground">{room.location} · {room.capacity}인</p>
                </div>
                <Sheet open={open && selectedRoomId === room.id} onOpenChange={(o) => setOpen(o)}>
                  <SheetTrigger asChild>
                    <Button onClick={() => { setSelectedRoomId(room.id); setOpen(true); }}>예약하기</Button>
                  </SheetTrigger>
                  <SheetContent side="right" className="bg-white p-6 rounded-l-md shadow-lg w-full sm:max-w-sm">
                    <BookingForm
                      date={date}
                      roomId={room.id}
                      busy={room.reservations.map(r => ({ start: r.start_time, end: r.end_time }))}
                      onDone={(ok, msg) => {
                        setOpen(false);
                        if (ok) {
                          toast({ description: '예약이 완료되었습니다.' });
                          // refresh list
                          getRoomsWithReservationsByDate(date).then(setRooms);
                        } else {
                          toast({ description: msg ?? '예약 실패', variant: 'destructive' });
                        }
                      }}
                    />
                  </SheetContent>
                </Sheet>
              </div>

              <div className="text-xs text-muted-foreground">
                {room.reservations.length === 0 ? (
                  <p>예약 없음</p>
                ) : (
                  <ul className="flex flex-wrap gap-2">
                    {room.reservations.map((r) => (
                      <li key={r.id} className="px-2 py-1 rounded bg-gray-100">
                        {r.start_time.slice(0,5)}~{r.end_time.slice(0,5)}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}

const bookingSchema = z.object({
  start: z.string(),
  end: z.string(),
  reserver_name: z.string().min(1, '이름을 입력해 주세요'),
  reserver_phone: z.string().regex(/^010-\d{4}-\d{4}$/i, '전화번호 형식: 010-0000-0000'),
  reserver_password: z.string().min(4, '비밀번호는 4자 이상'),
}).refine((data) => data.end > data.start, {
  message: '종료 시간은 시작 시간보다 늦어야 합니다',
  path: ['end'],
});

type BookingFormValues = z.infer<typeof bookingSchema>;

function BookingForm({
  date,
  roomId,
  busy,
  onDone,
}: {
  date: string;
  roomId: string;
  busy: { start: string; end: string }[];
  onDone: (ok: boolean, message?: string) => void;
}) {
  const timeSlots = useMemo(() => generateTimeSlots(9, 18, 30), []);
  const {
    register,
    handleSubmit,
    watch,
    formState: { errors, isSubmitting },
    setValue,
    control,
  } = useForm<BookingFormValues>({
    resolver: zodResolver(bookingSchema),
    defaultValues: {
      start: '09:00:00',
      end: '09:30:00',
      reserver_name: '',
      reserver_phone: '',
      reserver_password: '',
    },
  });

  const start = watch('start');
  useEffect(() => {
    const next = nextSlot(start, timeSlots);
    if (watch('end') <= start) setValue('end', next);
  }, [start, timeSlots, watch, setValue]);

  const onSubmit = async (values: BookingFormValues) => {
    const overlap = busy.some((b) => isOverlapping(values.start, values.end, b.start, b.end));
    if (overlap) return onDone(false, '해당 시간은 이미 예약되어 있습니다');
    const result = await createReservation({
      room_id: roomId,
      reservation_date: date,
      start_time: values.start,
      end_time: values.end,
      reserver_name: values.reserver_name,
      reserver_phone: values.reserver_phone,
      reserver_password: values.reserver_password,
    });
    if (!result.success) return onDone(false, result.error);
    onDone(true);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <SheetHeader>
        <SheetTitle>예약 생성</SheetTitle>
      </SheetHeader>
      <div className="grid grid-cols-2 gap-3">
        <div className="space-y-1">
          <Label>시작</Label>
          <Controller
            control={control}
            name="start"
            render={({ field }) => (
              <Select onValueChange={field.onChange} value={field.value}>
                <SelectTrigger><SelectValue /></SelectTrigger>
                <SelectContent>
                  {timeSlots.map((t) => (
                    <SelectItem key={t.value} value={t.value}>{t.label}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          />
        </div>
        <div className="space-y-1">
          <Label>종료</Label>
          <Controller
            control={control}
            name="end"
            render={({ field }) => (
              <Select onValueChange={field.onChange} value={field.value}>
                <SelectTrigger><SelectValue /></SelectTrigger>
                <SelectContent>
                  {timeSlots.map((t) => (
                    <SelectItem key={t.value} value={t.value}>{t.label}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          />
          {errors.end && <p className="text-xs text-red-600 mt-1">{errors.end.message}</p>}
        </div>
        <div className="space-y-1 col-span-2">
          <Label>이름</Label>
          <Input {...register('reserver_name')} />
          {errors.reserver_name && <p className="text-xs text-red-600 mt-1">{errors.reserver_name.message}</p>}
        </div>
        <div className="space-y-1 col-span-2">
          <Label>전화번호</Label>
          <Input placeholder="010-0000-0000" {...register('reserver_phone')} />
          {errors.reserver_phone && <p className="text-xs text-red-600 mt-1">{errors.reserver_phone.message}</p>}
        </div>
        <div className="space-y-1 col-span-2">
          <Label>비밀번호</Label>
          <Input type="password" {...register('reserver_password')} />
          {errors.reserver_password && <p className="text-xs text-red-600 mt-1">{errors.reserver_password.message}</p>}
        </div>
      </div>
      <div className="flex justify-end gap-2">
        <Button type="submit" disabled={isSubmitting}>{isSubmitting ? '예약 중...' : '예약'}</Button>
      </div>
    </form>
  );
}

function nextSlot(value: string, slots: { value: string }[]) {
  const idx = slots.findIndex((s) => s.value === value);
  return slots[Math.min(slots.length - 1, Math.max(0, idx + 1))].value;
}
</file>

<file path="src/lib/supabase/server.ts">
import "server-only";

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!url || !/^https?:\/\//.test(url)) {
    throw new Error(
      "Missing or invalid NEXT_PUBLIC_SUPABASE_URL. Set it to your https://<project>.supabase.co URL in .env.local or your hosting environment."
    );
  }
  if (!anonKey) {
    throw new Error(
      "Missing NEXT_PUBLIC_SUPABASE_ANON_KEY. Copy the anon key from Supabase project settings into .env.local or your hosting environment."
    );
  }

  return createServerClient(
    url,
    anonKey,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}

export async function createPureClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!url || !/^https?:\/\//.test(url)) {
    throw new Error(
      "Missing or invalid NEXT_PUBLIC_SUPABASE_URL. Set it to your https://<project>.supabase.co URL in .env.local or your hosting environment."
    );
  }
  if (!anonKey) {
    throw new Error(
      "Missing NEXT_PUBLIC_SUPABASE_ANON_KEY. Copy the anon key from Supabase project settings into .env.local or your hosting environment."
    );
  }

  return createServerClient(
    url,
    anonKey,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Time helpers for 30-min slot scheduling
export function generateTimeSlots(
  startHour = 9,
  endHour = 18,
  stepMinutes = 30
) {
  const slots: { label: string; value: string }[] = [];
  for (let h = startHour; h <= endHour; h++) {
    for (let m = 0; m < 60; m += stepMinutes) {
      if (h === endHour && m > 0) break;
      const hh = String(h).padStart(2, '0');
      const mm = String(m).padStart(2, '0');
      slots.push({ label: `${hh}:${mm}`, value: `${hh}:${mm}:00` });
    }
  }
  return slots;
}

export function isOverlapping(
  aStart: string,
  aEnd: string,
  bStart: string,
  bEnd: string
) {
  return aStart < bEnd && bStart < aEnd;
}
</file>

<file path="doc/prd.mdc">
---
description: Product Requirements Document for Meeting Room System
globs:
alwaysApply: true
---

# PRD - ?뚯쓽??愿由??쒖뒪??
## 1. ?쒗뭹 媛쒖슂

### 1.1 ?꾨줈?앺듃 紐⑺몴
- **MVP ?뚯쓽??愿由??쒖뒪??媛쒕컻**
- **?ъ슜??*: ?뚯쓽???덉빟 諛?議고쉶 湲곕뒫
- **愿由ъ옄**: ?뚯쓽??CRUD 愿由?湲곕뒫
- **紐⑤뜕?섍퀬 ?ы뵆???붿옄??* (Apple ?ㅽ???

### 1.2 湲곗닠 ?ㅽ깮
- **Frontend**: Next.js 14+ (App Router), TypeScript
- **Backend**: Supabase (PostgreSQL 15+)
- **諛고룷**: Vercel (GitHub ?곕룞 ?먮룞 諛고룷)
- **?ㅽ??쇰쭅**: Tailwind CSS + shadcn-ui
- **?ㅼ떆媛?*: Supabase Realtime
- **??愿由?*: React Hook Form + Zod

### 1.3 ?듭떖 ?먯튃
- **Over Engineering 諛⑹?**
- **湲곕낯??異⑹떎??援ы쁽**
- **?먮윭 ?곹솴 理쒖냼??*
- **?ㅼ떆媛??곗씠???숆린??*
- **????덉쟾??蹂댁옣** (TypeScript)

## 2. ?ъ슜???붽뎄?ы빆

### 2.1 ?ъ슜??(?쇰컲)

#### ?꾩껜 ?덉빟 ?꾪솴 議고쉶
- 5媛??닿쾶?ㅼ쓽 ?ㅼ떆媛??덉빟 ?꾪솴 ?뺤씤
- ?좎쭨蹂? ?쒓컙?蹂??덉빟 ?곹깭 ?쒓컖??- ?덉빟 媛?ν븳 ?쒓컙? ?쒖떆
- 紐⑤컮??諛섏쓳??吏??
#### ?뚯쓽???덉빟
- ?먰븯???닿쾶?ㅺ낵 ?쒓컙? ?좏깮
- ?덉빟???뺣낫 ?낅젰 (?대쫫, ?대??곕쾲?? 鍮꾨?踰덊샇)
- 以묐났 ?덉빟 諛⑹? 諛??ㅼ떆媛?寃利?- ?덉빟 ?꾨즺 利됱떆 ?꾪솴 ?낅뜲?댄듃

#### ???덉빟 議고쉶
- ?대??곕쾲??+ 鍮꾨?踰덊샇濡?媛쒖씤 ?덉빟 議고쉶
- ?덉빟 ?곸꽭 ?뺣낫 ?뺤씤
- ?덉빟 痍⑥냼 湲곕뒫 (?쒗븳 ?쒓컙 ??

### 2.2 愿由ъ옄

#### ?뚯쓽??愿由?(CRUD)
- **?뚯쓽???깅줉** (?대쫫, ?꾩튂, ?섏슜?몄썝)
- **?뚯쓽???뺣낫 ?섏젙**
- **?뚯쓽????젣** (湲곗〈 ?덉빟 泥섎━)
- **?뚯쓽??紐⑸줉 議고쉶**

## 3. 湲곕뒫 ?ㅽ럺

### 3.1 ?뚯쓽???뺣낫
- **?뚯쓽???섎웾**: 5媛??닿쾶??- **?뚯쓽???띿꽦**: ?대쫫, ?꾩튂, ?섏슜 媛???몄썝
- **湲곕낯 ?쒓났**: ?닿쾶??A~E (?붾? ?곗씠??

### 3.2 ?덉빟 ?쒖뒪??- **?덉빟 ?⑥쐞**: 30遺??⑥쐞
- **?덉빟 ?뺣낫**: ?좎쭨, ?쒖옉?쒓컙, 醫낅즺?쒓컙, ?덉빟???뺣낫
- **?몄쬆 諛⑹떇**: ?대??곕쾲??+ 鍮꾨?踰덊샇
- **?곹깭 愿由?*: ?쒖꽦(active), 痍⑥냼(cancelled)

### 3.3 ?쒓컙 愿由?- **以묐났 諛⑹?**: ?숈씪 ?뚯쓽?? ?숈씪 ?쒓컙 以묐났 ?덉빟 遺덇?
- **?ㅼ떆媛??숆린??*: ?덉빟 ?앹꽦/痍⑥냼 ??利됱떆 ?꾪솴 ?낅뜲?댄듃

## 4. ?ъ슜???ㅽ넗由?
### 4.1 ?ъ슜???쒕굹由ъ삤

**Story 1: ?뚯쓽???덉빟**
```
As a ?ъ슜??I want to ?꾩껜 ?덉빟 ?꾪솴??蹂닿퀬 ?먰븯???쒓컙???뚯쓽?ㅼ쓣 ?덉빟?섍퀬 ?띕떎
So that ?꾩슂?????뚯쓽 怨듦컙???뺣낫?????덈떎

Given ?꾩껜 ?덉빟 ?꾪솴 ?섏씠吏???묎렐?덉쓣 ??When ?먰븯???뚯쓽?ㅼ쓽 ?덉빟 踰꾪듉???대┃?섍퀬
And ?좎쭨, ?쒓컙, 媛쒖씤?뺣낫瑜??낅젰?섎㈃
Then ?덉빟???앹꽦?섍퀬 ?꾪솴??利됱떆 ?낅뜲?댄듃?쒕떎
```

**Story 2: ???덉빟 議고쉶**
```
As a ?ъ슜?? 
I want to ?닿? ?덉빟???뚯쓽?ㅼ쓣 議고쉶?섍퀬 愿由ы븯怨??띕떎
So that ?덉빟 ?꾪솴???뺤씤?섍퀬 ?꾩슂??痍⑥냼?????덈떎

Given ???덉빟 議고쉶 ?섏씠吏?먯꽌
When ?대??곕쾲?몄? 鍮꾨?踰덊샇瑜??낅젰?섎㈃
Then ???덉빟 紐⑸줉???쒖떆?섍퀬 痍⑥냼?????덈떎
```

### 4.2 愿由ъ옄 ?쒕굹由ъ삤

**Story 3: ?뚯쓽??愿由?*
```
As a 愿由ъ옄
I want to ?뚯쓽?ㅼ쓣 ?깅줉, ?섏젙, ??젣?섍퀬 ?띕떎
So that ?뚯쓽???댁쁺???⑥쑉?곸쑝濡?愿由ы븷 ???덈떎

Given 愿由ъ옄 ?섏씠吏???묎렐?덉쓣 ??When ?뚯쓽???뺣낫瑜??낅젰?섍굅???섏젙?섎㈃
Then 蹂寃쎌궗??씠 利됱떆 諛섏쁺?섍퀬 ?ъ슜?먯뿉寃?蹂댁뿬吏꾨떎
```

## 5. ?곸꽭 ?좎??뚮줈??
### 5.1 ?뚯쓽???덉빟 ?뚮줈??```
?낅젰: ?꾩껜 ?꾪솴 ?섏씠吏(/) ???뚯쓽???좏깮 ???덉빟 踰꾪듉 ?대┃ ???뺣낫 ?낅젰
泥섎━: ?쒓컙 以묐났 ?뺤씤 ???좏슚??寃利???DB ??????ㅼ떆媛??낅뜲?댄듃
異쒕젰: ?덉빟 ?꾨즺 硫붿떆吏 ???낅뜲?댄듃???꾪솴 ?쒖떆
```

### 5.2 ???덉빟 議고쉶 ?뚮줈??```
?낅젰: 議고쉶 ?섏씠吏(/my-reservations) ???대??곕쾲??鍮꾨?踰덊샇 ?낅젰 ??議고쉶 踰꾪듉
泥섎━: ?몄쬆 ?뺤씤 ??媛쒖씤 ?덉빟 ?곗씠??議고쉶 ??紐⑸줉 ?앹꽦
異쒕젰: ?덉빟 紐⑸줉 ?쒖떆 ???곸꽭 ?뺣낫 諛?痍⑥냼 ?듭뀡
```

### 5.3 愿由ъ옄 ?뚯쓽??愿由??뚮줈??```
?낅젰: 愿由ъ옄 ?섏씠吏(/admin) ??CRUD 踰꾪듉 ???뚯쓽???뺣낫 ?낅젰/?섏젙
泥섎━: 沅뚰븳 ?뺤씤 ???곗씠???좏슚??寃利???DB ?낅뜲?댄듃
異쒕젰: ?깃났 硫붿떆吏 ???낅뜲?댄듃???뚯쓽??紐⑸줉
```

## 6. ?붾㈃ 援ъ꽦

### 6.1 ?ъ슜???붾㈃
- **硫붿씤 ?섏씠吏** (`app/page.tsx`): ?꾩껜 ?덉빟 ?꾪솴 + ?덉빟 湲곕뒫
- **???덉빟 ?섏씠吏** (`app/my-reservations/page.tsx`): 媛쒖씤 ?덉빟 議고쉶 諛?愿由?
### 6.2 愿由ъ옄 ?붾㈃
- **愿由ъ옄 ?섏씠吏** (`app/admin/page.tsx`): ?뚯쓽??CRUD 愿由?
### 6.3 怨듯넻 ?붿냼
- **?ㅻ퉬寃뚯씠??*: ?ъ슜??愿由ъ옄 ?섏씠吏 ?꾪솚
- **紐⑤떖**: ?덉빟 ?앹꽦, ?뚯쓽??愿由???- **?뚮┝**: ?깃났/?ㅻ쪟 硫붿떆吏 ?쒖떆
- **濡쒕뵫 ?곹깭**: 鍮꾨룞湲??묒뾽 吏꾪뻾 ?곹솴

### 6.4 而댄룷?뚰듃 援ъ“
```
src/
?쒋?? app/                       # Next.js App Router
??  ?쒋?? layout.tsx            # 猷⑦듃 ?덉씠?꾩썐
??  ?쒋?? page.tsx              # ?덊럹?댁? (?덉빟 ?꾪솴)
??  ?쒋?? my-reservations/      # ???덉빟 議고쉶
??  ??  ?붴?? page.tsx
??  ?붴?? admin/                # 愿由ъ옄 ?섏씠吏
??      ?붴?? page.tsx
?쒋?? components/
??  ?쒋?? ui/                   # shadcn-ui 而댄룷?뚰듃
??  ?쒋?? user/                 # ?ъ슜??而댄룷?뚰듃
??  ?쒋?? admin/                # 愿由ъ옄 而댄룷?뚰듃
??  ?붴?? common/               # 怨듯넻 而댄룷?뚰듃
?붴?? lib/services/             # 鍮꾩쫰?덉뒪 濡쒖쭅
```

## 7. 鍮꾧린?μ쟻 ?붽뎄?ы빆

### 7.1 ?깅뒫
- **?묐떟 ?쒓컙**: 2珥??대궡 ?섏씠吏 濡쒕뵫
- **?ㅼ떆媛꾩꽦**: 1珥??대궡 ?곗씠???숆린??- **踰덈뱾 ?ш린**: 理쒖쟻?붾맂 肄붾뱶 遺꾪븷

### 7.2 ?ъ슜??- **諛섏쓳???붿옄??*: 紐⑤컮???쒕툝由??곗뒪?ы넲 吏??- **吏곴???UI**: 理쒖냼?쒖쓽 ?대┃?쇰줈 二쇱슂 湲곕뒫 ?묎렐
- **?먮윭 泥섎━**: 紐낇솗???ㅻ쪟 硫붿떆吏 ?쒓났
- **?묎렐??*: WCAG 2.1 AA ?섏? 吏??
### 7.3 ?덉젙??- **?곗씠??臾닿껐??*: 以묐났 ?덉빟 諛⑹?, ?몃옖??뀡 蹂댁옣
- **?먮윭 蹂듦뎄**: ?ㅽ듃?뚰겕 ?ㅻ쪟 ???ъ떆??濡쒖쭅
- **????덉쟾??*: TypeScript濡??고????ㅻ쪟 諛⑹?

## 8. ?쒖빟?ы빆

### 8.1 湲곗닠???쒖빟
- **?몄쬆 ?쒖뒪??*: 蹂꾨룄 濡쒓렇???놁씠 ?대??곕쾲??鍮꾨?踰덊샇 諛⑹떇
- **沅뚰븳 愿由?*: ?⑥닚??愿由ъ옄/?ъ슜??援щ텇
- **?곗씠??蹂댁븞**: RLS 鍮꾪솢?깊솕 (?⑥닚??援ъ“ ?좎?)

### 8.2 鍮꾩쫰?덉뒪 ?쒖빟
- **?덉빟 ?⑥쐞**: 理쒖냼 30遺??⑥쐞 ?덉빟
- **?덉빟 湲곌컙**: ?뱀씪遺??1二쇱씪 ?꾧퉴吏
- **痍⑥냼 ?뺤콉**: ?덉빟 ?쒓컙 1?쒓컙 ?꾧퉴吏 痍⑥냼 媛??
## 9. 湲곗닠??援ы쁽?ы빆

### 9.1 ?곗씠?곕쿋?댁뒪
```sql
-- ?듭떖 ?뚯씠釉?meeting_rooms: ?뚯쓽???뺣낫 (5媛??닿쾶??
reservations: ?덉빟 ?뺣낫 (?쒓컙 以묐났 諛⑹? ?쒖빟議곌굔)

-- 二쇱슂 ?쒖빟議곌굔
EXCLUDE USING GIST: 동일 일자 내 시간 겹침 방지 (timestamp range)
CASCADE DELETE: ?뚯쓽????젣 ???덉빟????젣
```

### 9.2 ?ㅼ떆媛??숆린??```typescript
// Supabase Realtime 援щ룆
const subscription = supabase
  .channel('reservations')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'reservations'
  }, handleRealtimeUpdate)
  .subscribe();
```

### 9.3 ????덉쟾??```typescript
// ?곗씠?곕쿋?댁뒪 ????뺤쓽
export interface Database {
  public: {
    Tables: {
      meeting_rooms: { /* ... */ };
      reservations: { /* ... */ };
    };
  };
}

// ?쒕퉬??寃곌낵 ???export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}
```

## 10. ?깃났 吏??
### 10.1 湲곕뒫???깃났
- [ ] 5媛??닿쾶???깅줉 諛?愿由?媛??- [ ] ?덉빟 ?앹꽦/議고쉶/痍⑥냼 湲곕뒫 ?뺤긽 ?묐룞
- [ ] ?쒓컙 以묐났 諛⑹? 濡쒖쭅 ?묐룞
- [ ] ?ㅼ떆媛??곗씠???숆린??援ы쁽

### 10.2 ?ъ슜??寃쏀뿕
- [ ] 吏곴??곸씤 ?덉빟 ?꾪솴 ?쒓컖??- [ ] 3?대┃ ?대궡 ?덉빟 ?꾨즺
- [ ] 紐낇솗???쇰뱶諛?諛??먮윭 泥섎━
- [ ] 紐⑤뜕?섍퀬 ?ы뵆???붿옄???곸슜

### 10.3 湲곗닠???깃났
- [ ] TypeScript 而댄뙆???ㅻ쪟 0媛?- [ ] 紐⑤컮??諛섏쓳??100% 吏??- [ ] ?섏씠吏 濡쒕뵫 ?쒓컙 2珥??대궡
- [ ] ?ㅼ떆媛??낅뜲?댄듃 1珥??대궡

## 11. ?ν썑 ?뺤옣 怨꾪쉷

### 11.1 ?④린 ?뺤옣 (v1.1)
- ?대찓???뚮┝ 湲곕뒫
- ?덉빟 ?듦퀎 ??쒕낫??- ?뚯쓽???대?吏 ?낅줈??
### 11.2 以묎린 ?뺤옣 (v2.0)
- ?ъ슜???몄쬆 ?쒖뒪??- ?덉빟 ?뱀씤 ?뚰겕?뚮줈??- 紐⑤컮????媛쒕컻

### 11.3 ?κ린 ?뺤옣 (v3.0)
- ?ㅼ쨷 嫄대Ъ 吏??- API 媛쒕갑
- ?몃? 罹섎┛???곕룞
</file>

<file path="doc/trd.mdc">
---
description: Technical Requirements Document for Meeting Room System
globs:
alwaysApply: true
---

# TRD - ?뚯쓽??愿由??쒖뒪??湲곗닠 ?붽뎄?ы빆

## 1. ?쒖뒪???꾪궎?띿쿂

### 1.1 湲곗닠 ?ㅽ깮
- **Frontend**: Next.js 14+ (React 18+, App Router)
- **Database**: Supabase (PostgreSQL 15+)
- **Styling**: Tailwind CSS 3+ + shadcn-ui
- **Deployment**: Vercel
- **Language**: TypeScript
- **Real-time**: Supabase Realtime
- **Form Management**: React Hook Form + Zod

### 1.2 ?꾪궎?띿쿂 ?⑦꽩
```
?뚢?????????????????????  Presentation  ????React Components (UI)
?쒋?????????????????????Business Logic  ????Services (鍮꾩쫰?덉뒪 濡쒖쭅)
?쒋????????????????????? Data Access    ????Supabase Client
?쒋?????????????????????   Database     ????PostgreSQL (Supabase)
?붴???????????????????```

### 1.3 ?대뜑 援ъ“ (App Router)
```
src/
?쒋?? app/                       # Next.js App Router
??  ?쒋?? globals.css           # 湲濡쒕쾶 ?ㅽ?????  ?쒋?? layout.tsx            # 猷⑦듃 ?덉씠?꾩썐
??  ?쒋?? page.tsx              # ?덊럹?댁? (?덉빟 ?꾪솴)
??  ?쒋?? my-reservations/      # ???덉빟 議고쉶
??  ??  ?붴?? page.tsx
??  ?붴?? admin/                # 愿由ъ옄 ?섏씠吏
??      ?붴?? page.tsx
?쒋?? components/
??  ?쒋?? ui/                   # shadcn-ui 而댄룷?뚰듃
??  ?쒋?? admin/                # 愿由ъ옄 而댄룷?뚰듃
??  ?쒋?? user/                 # ?ъ슜??而댄룷?뚰듃
??  ?붴?? common/               # 怨듯넻 而댄룷?뚰듃
?쒋?? lib/
??  ?쒋?? supabase/             # Supabase ?대씪?댁뼵????  ??  ?쒋?? client.ts         # ?대씪?댁뼵???ъ씠????  ??  ?붴?? server.ts         # ?쒕쾭 ?ъ씠????  ?쒋?? services/             # 鍮꾩쫰?덉뒪 濡쒖쭅
??  ?붴?? utils.ts              # ?좏떥由ы떚
?붴?? types/                    # ????뺤쓽
    ?쒋?? database.ts           # Supabase ?곗씠?곕쿋?댁뒪 ???    ?붴?? index.ts              # 怨듯넻 ???```

## 2. ?곗씠?곕쿋?댁뒪 ?ㅺ퀎

### 2.1 ?뚯씠釉??ㅽ궎留?
**meeting_rooms ?뚯씠釉?*
```sql
CREATE TABLE IF NOT EXISTS meeting_rooms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    location VARCHAR(200) NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**reservations ?뚯씠釉?*
```sql
CREATE TABLE IF NOT EXISTS reservations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    room_id UUID NOT NULL REFERENCES meeting_rooms(id) ON DELETE CASCADE,
    reservation_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    reserver_name VARCHAR(50) NOT NULL,
    reserver_phone VARCHAR(20) NOT NULL,
    -- 鍮꾨?踰덊샇???댁떆濡????(pgcrypto: bcrypt)
    password_hash TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'cancelled')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 2.2 ?몃뜳??諛??쒖빟議곌굔
```sql
-- ?쒓컙 以묐났 諛⑹? (GIST ?뺤옣 ?꾩슂)
CREATE EXTENSION IF NOT EXISTS btree_gist;

ALTER TABLE reservations 
ADD CONSTRAINT no_overlapping_reservations 
EXCLUDE USING GIST (
    room_id WITH =,
    reservation_date WITH =,
    tsrange(
      (reservation_date::timestamp + start_time),
      (reservation_date::timestamp + end_time)
    ) WITH &&
) WHERE (status = 'active');

-- ?깅뒫 理쒖쟻???몃뜳??CREATE INDEX IF NOT EXISTS idx_reservations_phone ON reservations(reserver_phone);
CREATE INDEX IF NOT EXISTS idx_reservations_date_room ON reservations(reservation_date, room_id, status);
CREATE INDEX IF NOT EXISTS idx_meeting_rooms_name ON meeting_rooms(name);

-- 개별 예약 유효성
ALTER TABLE reservations
ADD CONSTRAINT reservations_end_after_start
CHECK (end_time > start_time);

-- 보안/권한 요약
-- - RLS 활성화: meeting_rooms, reservations
-- - reservations 열 권한: anon/authenticated에게 민감 열(전화, 비밀번호) 미공개
-- - 공개 뷰: public_reservations(id, room_id, reservation_date, start_time, end_time, status, created_at, updated_at)
-- - RPC: create_reservation(), cancel_reservation()로 예약/취소 수행
```

## 3. TypeScript ????뺤쓽

### 3.1 ?곗씠?곕쿋?댁뒪 ???(types/database.ts)
```typescript
export interface Database {
  public: {
    Tables: {
      meeting_rooms: {
        Row: {
          id: string;
          name: string;
          location: string;
          capacity: number;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          name: string;
          location: string;
          capacity: number;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          name?: string;
          location?: string;
          capacity?: number;
          created_at?: string;
          updated_at?: string;
        };
      };
      reservations: {
        Row: {
          id: string;
          room_id: string;
          reservation_date: string;
          start_time: string;
          end_time: string;
          reserver_name: string;
          reserver_phone: string;
          // 誘쇨컧 ?뺣낫???몄텧?섏? ?딆쓬 (password_hash 誘몃끂異?
          status: 'active' | 'cancelled';
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          room_id: string;
          reservation_date: string;
          start_time: string;
          end_time: string;
          reserver_name: string;
          reserver_phone: string;
          // ?덉빟 ?앹꽦? RPC瑜??듯빐 泥섎━ (鍮꾨?踰덊샇???쒕쾭?먯꽌 ?댁떆)
          status?: 'active' | 'cancelled';
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          room_id?: string;
          reservation_date?: string;
          start_time?: string;
          end_time?: string;
          reserver_name?: string;
          reserver_phone?: string;
          // 鍮꾨?踰덊샇 媛깆떊? 蹂꾨룄 ?덉감 (吏곸젒 媛깆떊 湲덉?)
          status?: 'active' | 'cancelled';
          created_at?: string;
          updated_at?: string;
        };
      };
    };
  };
}
```

### 3.2 怨듯넻 ???(types/index.ts)
```typescript
export type Room = Database['public']['Tables']['meeting_rooms']['Row'];
export type Reservation = Database['public']['Tables']['reservations']['Row'];

export interface CreateRoomData {
  name: string;
  location: string;
  capacity: number;
}

export interface CreateReservationData {
  room_id: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
}

export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface TimeSlot {
  start: string;
  end: string;
}

export interface RoomWithReservations extends Room {
  reservations: Reservation[];
}

export interface ValidationErrors {
  [key: string]: string;
}

export interface ReservationFormData {
  reserver_name: string;
  reserver_phone: string;
  reserver_password: string;
  reservation_date: string;
  start_time: string;
  end_time: string;
}

export interface RoomFormData {
  name: string;
  location: string;
  capacity: number;
}
```

## 4. 而댄룷?뚰듃 ?ㅺ퀎

### 4.1 ?ъ슜??而댄룷?뚰듃

**BookingCalendar.tsx**
```typescript
interface BookingCalendarProps {
  selectedDate: Date;
  onDateChange: (date: Date) => void;
  onBookingClick: (roomId: string, timeSlot: TimeSlot) => void;
}

interface BookingCalendarState {
  rooms: Room[];
  reservations: Reservation[];
  loading: boolean;
  error: string | null;
}
```

**ReservationForm.tsx**
```typescript
interface ReservationFormProps {
  roomId: string;
  selectedDate: Date;
  selectedTime: TimeSlot;
  onSubmit: (data: ReservationFormData) => Promise<void>;
  onCancel: () => void;
}

interface ReservationFormState {
  formData: ReservationFormData;
  errors: ValidationErrors;
  submitting: boolean;
}
```

**MyReservations.tsx**
```typescript
interface MyReservationsProps {}

interface MyReservationsState {
  phone: string;
  password: string;
  reservations: Reservation[];
  loading: boolean;
  authenticated: boolean;
  error: string | null;
}
```

### 4.2 愿由ъ옄 而댄룷?뚰듃

**AdminRoomList.tsx**
```typescript
interface AdminRoomListProps {}

interface AdminRoomListState {
  rooms: Room[];
  loading: boolean;
  selectedRoom: Room | null;
  showForm: boolean;
  error: string | null;
}
```

**RoomForm.tsx**
```typescript
interface RoomFormProps {
  room?: Room;
  onSubmit: (data: RoomFormData) => Promise<void>;
  onCancel: () => void;
}

interface RoomFormState {
  formData: RoomFormData;
  errors: ValidationErrors;
  submitting: boolean;
}
```

## 5. ?쒕퉬???덉씠???ㅺ퀎

### 5.1 roomService.ts
```typescript
export const roomService = {
  // 紐⑤뱺 ?뚯쓽??議고쉶
  async getAllRooms(): Promise<Room[]> {
    const { data, error } = await supabase
      .from('meeting_rooms')
      .select('*')
      .order('name');
    
    if (error) throw error;
    return data;
  },
  
  // ?뚯쓽???앹꽦  
  async createRoom(data: CreateRoomData): Promise<ServiceResult<Room>> {
    try {
      const { data: room, error } = await supabase
        .from('meeting_rooms')
        .insert(data)
        .select()
        .single();
      
      if (error) throw error;
      
      return { success: true, data: room };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : '?뚯쓽???앹꽦???ㅽ뙣?덉뒿?덈떎' 
      };
    }
  },
  
  // ?뚯쓽???섏젙
  async updateRoom(id: string, data: Partial<CreateRoomData>): Promise<ServiceResult<Room>> {
    try {
      const { data: room, error } = await supabase
        .from('meeting_rooms')
        .update(data)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      
      return { success: true, data: room };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : '?뚯쓽???섏젙???ㅽ뙣?덉뒿?덈떎' 
      };
    }
  },
  
  // ?뚯쓽????젣
  async deleteRoom(id: string): Promise<ServiceResult<void>> {
    try {
      const { error } = await supabase
        .from('meeting_rooms')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : '?뚯쓽????젣???ㅽ뙣?덉뒿?덈떎' 
      };
    }
  }
};
```

### 5.2 reservationService.ts
```typescript
export const reservationService = {
  // ?덉빟 ?꾪솴 議고쉶
  async getReservationsByDate(date: Date): Promise<RoomWithReservations[]> {
    const dateString = format(date, 'yyyy-MM-dd');
    
    const { data, error } = await supabase
      .from('meeting_rooms')
      .select(`
        *,
        reservations!inner(
          id,
          reservation_date,
          start_time,
          end_time,
          reserver_name,
          status
        )
      `)
      .eq('reservations.reservation_date', dateString)
      .eq('reservations.status', 'active')
      .order('name');
    
    if (error) throw error;
    return data;
  },
  
  // ?덉빟 ?앹꽦
  async createReservation(data: CreateReservationData): Promise<ServiceResult<Reservation>> {
    try {
      // ?쒓컙 以묐났 ?뺤씤
      const conflictCheck = await this.checkTimeConflict(
        data.room_id,
        data.reservation_date,
        data.start_time,
        data.end_time
      );
      
      if (conflictCheck) {
        return { 
          success: false, 
          error: '?좏깮???쒓컙???대? ?덉빟???덉뒿?덈떎' 
        };
      }
      
      const { data: reservation, error } = await supabase
        .from('reservations')
        .insert(data)
        .select()
        .single();
      
      if (error) throw error;
      
      return { success: true, data: reservation };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : '?덉빟 ?앹꽦???ㅽ뙣?덉뒿?덈떎' 
      };
    }
  },
  
  // 媛쒖씤 ?덉빟 議고쉶
  async getMyReservations(phone: string, password: string): Promise<Reservation[]> {
    const { data, error } = await supabase
      .from('reservations')
      .select(`
        *,
        meeting_rooms(name, location)
      `)
      .eq('reserver_phone', phone)
      .eq('reserver_password', password)
      .order('reservation_date', { ascending: false });
    
    if (error) throw error;
    return data;
  },
  
  // ?덉빟 痍⑥냼
  async cancelReservation(id: string, phone: string, password: string): Promise<ServiceResult<void>> {
    try {
      const { error } = await supabase
        .from('reservations')
        .update({ status: 'cancelled' })
        .eq('id', id)
        .eq('reserver_phone', phone)
        .eq('reserver_password', password);
      
      if (error) throw error;
      
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : '?덉빟 痍⑥냼???ㅽ뙣?덉뒿?덈떎' 
      };
    }
  },
  
  // ?쒓컙 以묐났 ?뺤씤
  async checkTimeConflict(
    roomId: string, 
    date: string, 
    startTime: string, 
    endTime: string
  ): Promise<boolean> {
    const { data, error } = await supabase
      .rpc('check_time_conflict', {
        p_room_id: roomId,
        p_date: date,
        p_start_time: startTime,
        p_end_time: endTime
      });
    
    if (error) throw error;
    return data > 0;
  }
};
```

## 6. ?ㅼ떆媛??숆린???ㅺ퀎

### 6.1 Supabase Realtime ?ㅼ젙
```typescript
// ?ㅼ떆媛?援щ룆 ?ㅼ젙
const subscription = supabase
  .channel('reservations')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'reservations'
  }, handleRealtimeUpdate)
  .subscribe();

// ?ㅼ떆媛??낅뜲?댄듃 泥섎━
function handleRealtimeUpdate(payload: RealtimePostgresChangesPayload<any>) {
  switch(payload.eventType) {
    case 'INSERT':
      // ???덉빟 異붽?
      setReservations(prev => [...prev, payload.new as Reservation]);
      break;
    case 'UPDATE': 
      // ?덉빟 ?섏젙/痍⑥냼
      setReservations(prev => 
        prev.map(r => r.id === payload.new.id ? payload.new as Reservation : r)
      );
      break;
    case 'DELETE':
      // ?덉빟 ??젣
      setReservations(prev => 
        prev.filter(r => r.id !== payload.old.id)
      );
      break;
  }
}
```

## 7. ?섍꼍 ?ㅼ젙

### 7.1 ?섍꼍蹂??```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key

# .env.production (Vercel)
NEXT_PUBLIC_SUPABASE_URL=production-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=production-key
```

### 7.2 Supabase ?대씪?댁뼵???ㅼ젙
```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

// lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database';

export const createClient = () => {
  const cookieStore = cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // SSR?먯꽌 荑좏궎 ?ㅼ젙 ?ㅽ뙣 ??臾댁떆
          }
        },
      },
    }
  );
};
```

### 7.3 Tailwind CSS ?ㅼ젙
```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Apple ?ㅽ???而щ윭 ?붾젅??        'apple-blue': '#007AFF',
        'apple-gray': '#F2F2F7',
        'apple-green': '#34C759',
        'apple-red': '#FF3B30',
      },
      fontFamily: {
        sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
      },
    },
  },
  plugins: [],
};
```

## 8. ?깅뒫 理쒖쟻??
### 8.1 ?곗씠?곕쿋?댁뒪 理쒖쟻??- **?몃뜳???쒖슜**: ?먯＜ 議고쉶?섎뒗 而щ읆???몃뜳???앹꽦
- **荑쇰━ 理쒖쟻??*: JOIN 荑쇰━ 理쒖냼?? ?꾩슂??而щ읆留?SELECT
- **Connection Pooling**: Supabase ?먮룞 愿由?
### 8.2 ?꾨줎?몄뿏??理쒖쟻??```typescript
// React.memo ?ъ슜 - 遺덊븘?뷀븳 由щ젋?붾쭅 諛⑹?
const RoomCard = React.memo(function RoomCard({ room, onSelect }: RoomCardProps) {
  return <div onClick={() => onSelect(room)}>{room.name}</div>;
});

// useMemo/useCallback ?ъ슜 - 怨꾩궛 鍮꾩슜 理쒖쟻??const timeSlots = useMemo(() => generateTimeSlots(), []);
const handleRoomSelect = useCallback((room: Room) => {
  setSelectedRoom(room);
}, []);
```

## 9. 蹂댁븞 怨좊젮?ы빆

### 9.1 ?곗씠??蹂댁븞
- **RLS 鍮꾪솢?깊솕**: ?⑥닚??援ъ“ ?좎? (?붽뎄?ы빆)
- **?낅젰 寃利?*: ?대씪?댁뼵???쒕쾭 ?묒そ 寃利?- **SQL Injection 諛⑹?**: Parameterized Query ?ъ슜

### 9.2 ?대씪?댁뼵??蹂댁븞
```typescript
// Zod瑜??쒖슜???낅젰 ?곗씠??寃利?import { z } from 'zod';

const reservationSchema = z.object({
  reserver_name: z.string().min(1, '?덉빟???대쫫???낅젰?댁＜?몄슂'),
  reserver_phone: z.string().regex(/^010-\d{4}-\d{4}$/, '?щ컮瑜??대??곕쾲?몃? ?낅젰?댁＜?몄슂'),
  reserver_password: z.string().min(4, '鍮꾨?踰덊샇??4?먮━ ?댁긽 ?낅젰?댁＜?몄슂'),
  reservation_date: z.string(),
  start_time: z.string(),
  end_time: z.string(),
});

export type ReservationFormData = z.infer<typeof reservationSchema>;

export function validateReservationData(data: unknown): ReservationFormData {
  return reservationSchema.parse(data);
}
```

## 10. ?뚯뒪???꾨왂

### 10.1 ?⑥쐞 ?뚯뒪??```typescript
// __tests__/services/roomService.test.ts
import { roomService } from '@/lib/services/roomService';

describe('roomService', () => {
  test('should create room successfully', async () => {
    const roomData: CreateRoomData = {
      name: 'Test Room',
      location: 'Test Location', 
      capacity: 6
    };
    
    const result = await roomService.createRoom(roomData);
    expect(result.success).toBe(true);
    expect(result.data?.name).toBe('Test Room');
  });
  
  test('should handle duplicate room names', async () => {
    const roomData: CreateRoomData = {
      name: 'Duplicate Room',
      location: 'Test Location',
      capacity: 4
    };
    
    await roomService.createRoom(roomData);
    const result = await roomService.createRoom(roomData);
    
    expect(result.success).toBe(false);
    expect(result.error).toContain('already exists');
  });
});
```

## 11. 諛고룷 ?ㅼ젙

### 11.1 Vercel 諛고룷 ?ㅼ젙
```json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "@supabase-url",
    "NEXT_PUBLIC_SUPABASE_ANON_KEY": "@supabase-anon-key"
  }
}
```

### 11.2 GitHub Actions (?좏깮??
```yaml
# .github/workflows/deploy.yml
name: Deploy to Vercel
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run build
      - run: npm run test
```

## 12. 紐⑤땲?곕쭅 諛?濡쒓퉭

### 12.1 ?먮윭 異붿쟻
```typescript
// ?먮윭 泥섎━ ?⑦꽩
try {
  const result = await reservationService.createReservation(data);
  return result;
} catch (error) {
  console.error('Reservation creation failed:', error);
  
  // ?꾨줈?뺤뀡?먯꽌???몃? 紐⑤땲?곕쭅 ?쒕퉬???ъ슜
  if (process.env.NODE_ENV === 'production') {
    // Sentry, LogRocket ??  }
  
  throw new Error('?덉빟 ?앹꽦???ㅽ뙣?덉뒿?덈떎');
}
```

### 12.2 ?깅뒫 紐⑤땲?곕쭅
```typescript
// ?깅뒫 痢≪젙
const startTime = performance.now();
await someAsyncOperation();
const duration = performance.now() - startTime;

if (duration > 1000) {
  console.warn(`Slow operation detected: ${duration}ms`);
}
```

??湲곗닠 臾몄꽌??TypeScript? App Router瑜?湲곕컲?쇰줈 ???덉젙?곸씠怨??뺤옣 媛?ν븳 ?뚯쓽??愿由??쒖뒪??援ы쁽???꾪븳 湲곗닠??媛?대뱶?쇱씤???쒓났?⑸땲??
</file>

<file path="package.json">
{
  "name": "dbtest2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:ui": "vitest --ui"
  },
  "dependencies": {
    "@hookform/resolvers": "^4",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.6",
    "@supabase/ssr": "0.5.2",
    "@tanstack/react-query": "^5",
    "autoprefixer": "10.4.20",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4",
    "es-toolkit": "^1",
    "framer-motion": "^11",
    "lucide-react": "^0.469.0",
    "next": "15.1.0",
    "next-themes": "^0.4.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7",
    "react-use": "^17",
    "server-only": "0.0.1",
    "ts-pattern": "^5",
    "zod": "^3",
    "zustand": "^4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/typography": "^0.5.10",
    "@testing-library/jest-dom": "^6.8.0",
    "@testing-library/react": "^16.3.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@vitejs/plugin-react": "^5.0.2",
    "@vitest/ui": "^3.2.4",
    "eslint": "^9",
    "eslint-config-next": "15.1.0",
    "jsdom": "^27.0.0",
    "postcss": "^8",
    "supabase": "^2.40.7",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^3.4.1",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5",
    "vitest": "^3.2.4"
  }
}
</file>

</files>
